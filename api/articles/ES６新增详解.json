{"title":"ES6新增详解","uid":"0b7869d8948a44428f2ef3d011726b80","slug":"ES６新增详解","date":"2022-12-26T13:14:11.604Z","updated":"2022-12-26T13:14:11.604Z","comments":true,"path":"api/articles/ES６新增详解.json","keywords":null,"cover":null,"content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h1 id=\"ES6-新增详解\"><a href=\"#ES6-新增详解\" class=\"headerlink\" title=\"ES6 新增详解\"></a>ES6 新增详解</h1><h2 id=\"let-声明变量和-const-声明常量，两个都有块级作用域\"><a href=\"#let-声明变量和-const-声明常量，两个都有块级作用域\" class=\"headerlink\" title=\"let 声明变量和 const 声明常量，两个都有块级作用域\"></a>let 声明变量和 const 声明常量，两个都有块级作用域</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">ES5中是没有块级作用域的，并且var有变量提升，在let中，使用的变量一定要进行声明<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h2 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">ES6中的函数定义不再使用关键字function()，而是利用了()&#x3D;&gt;来进行定义\n\n特点：箭头函数中的this始终指向箭头函数定义时的离this最近的一个函数，如果没有最近的函数就指向window。<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"模板字符串\"><a href=\"#模板字符串\" class=\"headerlink\" title=\"模板字符串\"></a>模板字符串</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">模板字符串是增强版的字符串，用反引号（&#96;）标识，可以当作普通字符串使用，也可以用来定义多行字符串<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h2 id=\"解构赋值\"><a href=\"#解构赋值\" class=\"headerlink\" title=\"解构赋值\"></a>解构赋值</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h2 id=\"for-…-of…循环\"><a href=\"#for-…-of…循环\" class=\"headerlink\" title=\"for … of…循环\"></a>for … of…循环</h2><pre class=\"line-numbers language-Java\" data-language=\"Java\"><code class=\"language-Java\">for…of循环可以遍历数组、Set和Map结构、某些类似数组的对象、对象，以及字符串\n应用场景\n&#x2F;&#x2F;arguments是个类数组对象，通常先要将其转换为数组才能遍历，但for...of可以直接遍历<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"import、export-导入导出\"><a href=\"#import、export-导入导出\" class=\"headerlink\" title=\"import、export 导入导出\"></a>import、export 导入导出</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">ES6标准中，Js原生支持模块(module)。将JS代码分割成不同功能的小块进行模块化，将不同功能的代码分别写在不同文件中，各模块只需导出公共接口部分，然后通过模块的导入的方式可以在其他地方使用<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"set-数据结构\"><a href=\"#set-数据结构\" class=\"headerlink\" title=\"set 数据结构\"></a>set 数据结构</h3><ul>\n<li><strong>方法：</strong>add()、delete()、has()、clear()</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Set数据结构，类似数组。所有的数据都是唯一的，没有重复的值。它本身是一个构造函数<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>应用 【数组去重、并集（Union）、交集（Intersect）和差集（Difference】</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">let arr &#x3D; [3, 5, 2, 2, 5, 5];\nlet unique &#x3D; [...new Set(arr)];\n&#x2F;&#x2F; [3, 5, 2]\n\n2、并集（Union）、交集（Intersect）和差集（Difference）<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"…-展开运算符\"><a href=\"#…-展开运算符\" class=\"headerlink\" title=\"… 展开运算符\"></a>… 展开运算符</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">可以将数组或对象里面的值展开；还可以将多个值收集为一个变量<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h2 id=\"应用-【合并数组、浅拷贝数组、类数组转数组、使用-Math-函数判断最大最小】\"><a href=\"#应用-【合并数组、浅拷贝数组、类数组转数组、使用-Math-函数判断最大最小】\" class=\"headerlink\" title=\"应用 【合并数组、浅拷贝数组、类数组转数组、使用 Math 函数判断最大最小】\"></a>应用 【合并数组、浅拷贝数组、类数组转数组、使用 Math 函数判断最大最小】</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">1. 合并数组\n\narr1.push(...arr2) &#x2F;&#x2F; 将arr2 追加到数组的末尾\narr1.unshift(...arr2) &#x2F;&#x2F; 将arr2 追加到数组的开头\n\n2. 拷贝数组\n\nvar arr &#x3D; [1,2,3];\nvar arr2 &#x3D; [...arr]; &#x2F;&#x2F; 和arr.slice()差不多\narr2.push(4)\n&#x2F;&#x2F;记住：数组中的对象依然是引用值，所以不是任何东西都“拷贝”过去了。\n\n3.将arguments或者NodeList转换为Array\n\nvar myFn &#x3D; function(...args) &#123;\n&#x2F;&#x2F; ...<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"修饰器-【比如-vue-的事件修饰符-代替-v-on-】\"><a href=\"#修饰器-【比如-vue-的事件修饰符-代替-v-on-】\" class=\"headerlink\" title=\"修饰器 @ 【比如 vue 的事件修饰符 代替 v-on:】\"></a>修饰器 @ 【比如 vue 的事件修饰符 代替 v-on:】</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">decorator【待 科 ra 腾】是一个函数，用来修改类甚至于是方法的行为。修饰器本质就是编译时执行的函数<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h2 id=\"class-类的继承\"><a href=\"#class-类的继承\" class=\"headerlink\" title=\"class 类的继承\"></a>class 类的继承</h2><h3 id=\"ES6-中不再像-ES5-一样使用原型链实现继承，而是引入-Class-这个概念-extends【继承】\"><a href=\"#ES6-中不再像-ES5-一样使用原型链实现继承，而是引入-Class-这个概念-extends【继承】\" class=\"headerlink\" title=\"ES6 中不再像 ES5 一样使用原型链实现继承，而是引入 Class 这个概念 extends【继承】\"></a>ES6 中不再像 ES5 一样使用原型链实现继承，而是引入 Class 这个概念 extends【继承】</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">class Person&#123;&#125; 父类\nclass Worker extends Person&#123;\nconstructor(name, age,job) &#123;\n         super(name, age);\n          this.job &#x3D; job;\n    &#125;\n&#125;  子继承父类<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<hr>\n<h2 id=\"promise\"><a href=\"#promise\" class=\"headerlink\" title=\"promise\"></a>promise</h2><p>Promise 是 ES6 提出的一种解决异步编程的方案，比传统的解决方案（回调函数和事件）更合理、强大</p>\n<p>它有三种状态，分别是 pending-进行中、fulfilled-已完成、rejected-已失败。</p>\n<p>【 可以链式调用解决回调地狱问题 】</p>\n<p>Promise 的实例方法有 .then()/.catch() /finally() 三种，</p>\n<p>静态方法有 all / race / allSettled [塞抖~] / any / resolve / reject 六种</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"><span class=\"token class-name\">Promise</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token class-name\">Promise</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span><span class=\"token function\">catch</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token class-name\">Promise</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span><span class=\"token function\">finally</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 不管 Promise 对象最后状态如何，都会执行的操作。</span>\nPromise<span class=\"token punctuation\">.</span><span class=\"token function\">all</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\">// 方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。所有参数数组 Promise 实例执行 resolve 回调后，新实例执行 resolve 回调；如果中间有任何一个 Promise 实例执行 reject 回调，那么新实例就直接执行 reject 回调了。</span>\nPromise<span class=\"token punctuation\">.</span>race<span class=\"token punctuation\">)</span>  <span class=\"token comment\">//顾名思义，就是竞赛，返回最快完成那一个 Promise 实例。只要参数数组中有一个 Promise 实例执行 resolve 回调或 reject 回调后，新实例就直接返回结果。</span>\nPromise<span class=\"token punctuation\">.</span><span class=\"token function\">allSettled</span><span class=\"token punctuation\">(</span> <span class=\"token punctuation\">)</span> <span class=\"token comment\">// 方法只有等到 参数 数组 的所有 Promise 实例都发生状态变更，返回的 Promise 实例才会发生状态变更，无论是执行 resolve 回调还是 reject 回调的状态。</span>\n'有时候，我们不关心异步操作的结果，只关心这些操作有没有结束。这时，Promise<span class=\"token punctuation\">.</span><span class=\"token function\">allSettled</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>方法就很有用。\nPromise<span class=\"token punctuation\">.</span><span class=\"token function\">any</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\">// 返回任意一个最快执行 resolve 回调的 Promise 实例。</span>\nPromise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\">// 方法返回一个以给定值解析后的 Promise 实例。相当于执行 then 方法里面的 _resolvePromise。</span>\nPromise<span class=\"token punctuation\">.</span><span class=\"token function\">reject</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 方法返回一个带有拒绝原因的 Promise 实例。</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<hr>\n<h2 id=\"Symbol\"><a href=\"#Symbol\" class=\"headerlink\" title=\"Symbol\"></a>Symbol</h2><p>是一种基本类型。Symbol 通过调用 symbol 函数产生，它接收一个可选的名字参数，该函数返回的 symbol 是唯一的</p>\n<ul>\n<li>Symbol 的值是唯一的，常用来解决命名冲突问题。</li>\n<li>Symbol 的值不能和其他数据进行运算。</li>\n</ul>\n<p>应用场景：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"><span class=\"token function\">应用场景1：使用Symbol来作为对象属性名</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span>\n\n应用场景<span class=\"token number\">2</span>：使用Symbol来替代常量\n\n应用场景<span class=\"token number\">3</span>：使用Symbol定义类的私有属性<span class=\"token operator\">/</span>方法\n\n<span class=\"token comment\">//正常的 Symbol</span>\n<span class=\"token keyword\">let</span> h1 <span class=\"token operator\">=</span> <span class=\"token function\">Symbol</span><span class=\"token punctuation\">(</span><span class=\"token string\">'小宝'</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">let</span> h2 <span class=\"token operator\">=</span> <span class=\"token function\">Symbol</span><span class=\"token punctuation\">(</span><span class=\"token string\">'小宝'</span><span class=\"token punctuation\">)</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>h1 <span class=\"token operator\">===</span> h2<span class=\"token punctuation\">)</span> <span class=\"token comment\">// false</span>\n\n<span class=\"token comment\">//相等的Symbol   ----使用 Symbol.for()</span>\n<span class=\"token keyword\">let</span> h3 <span class=\"token operator\">=</span> Symbol<span class=\"token punctuation\">.</span><span class=\"token function\">for</span><span class=\"token punctuation\">(</span><span class=\"token string\">'小宝'</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">let</span> h4 <span class=\"token operator\">=</span> Symbol<span class=\"token punctuation\">.</span><span class=\"token function\">for</span><span class=\"token punctuation\">(</span><span class=\"token string\">'小宝'</span><span class=\"token punctuation\">)</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>h1 <span class=\"token operator\">===</span> h2<span class=\"token punctuation\">)</span> <span class=\"token comment\">// true</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h2><p><code>Map</code>类型是键值对的有序列表，而键和值都可以是任意类型</p>\n<ul>\n<li><strong>属性和方法：</strong>size()、set()、get()、has()、delete()、clear()</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">\n<span class=\"token comment\">// 声明Map</span>\n        <span class=\"token keyword\">let</span> m <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Map</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n​\n        <span class=\"token comment\">// 1.添加元素(键值对)</span>\n        m<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span><span class=\"token string\">'name'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'小宝'</span><span class=\"token punctuation\">)</span>\n        m<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span><span class=\"token string\">'age'</span><span class=\"token punctuation\">,</span><span class=\"token number\">18</span><span class=\"token punctuation\">)</span>\n​\n        <span class=\"token comment\">// 2.获取元素</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">//小宝</span>\n​\n        <span class=\"token comment\">// 3.删除元素</span>\n        m<span class=\"token punctuation\">.</span><span class=\"token function\">delete</span><span class=\"token punctuation\">(</span><span class=\"token string\">'name'</span><span class=\"token punctuation\">)</span>\n​\n        <span class=\"token comment\">// 4.获取元素个数</span>\n        <span class=\"token keyword\">let</span> size <span class=\"token operator\">=</span> m<span class=\"token punctuation\">.</span>size\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>size<span class=\"token punctuation\">)</span> <span class=\"token comment\">//1</span>\n​\n        <span class=\"token comment\">// 5.检测是否包含某个元素</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">.</span><span class=\"token function\">has</span><span class=\"token punctuation\">(</span><span class=\"token string\">'age'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//true</span>\n\n        <span class=\"token comment\">// 6.清空Map</span>\n        m<span class=\"token punctuation\">.</span><span class=\"token function\">clear</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">)</span> <span class=\"token comment\">//0</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<hr>\n<h2 id=\"Proxy-代理\"><a href=\"#Proxy-代理\" class=\"headerlink\" title=\"Proxy 代理\"></a>Proxy 代理</h2><p>使用代理（Proxy）监听对象的操作，然后可以做一些相应事情</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">\n<span class=\"token constant\">ES6</span>原生提供了Proxy构造函数，用来生成Proxy实例。\n\n<span class=\"token keyword\">var</span> proxy <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Proxy</span><span class=\"token punctuation\">(</span>target<span class=\"token punctuation\">,</span> handler<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nProxy对象的所有用法，都是上面的这种形式。不同的只是handle参数的写法。其中<span class=\"token keyword\">new</span> <span class=\"token class-name\">Proxy</span>用来生成Proxy实例，target是表示所要拦截的对象，handle是用来定制拦截行为的对象。\n\n<span class=\"token keyword\">var</span> proxy <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Proxy</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token function-variable function\">get</span><span class=\"token operator\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">target<span class=\"token punctuation\">,</span> property</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">35</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nproxy<span class=\"token punctuation\">.</span>time <span class=\"token comment\">// 35</span>\nproxy<span class=\"token punctuation\">.</span>name <span class=\"token comment\">// 35</span>\nproxy<span class=\"token punctuation\">.</span>title <span class=\"token comment\">// 35</span>\n上面是一个拦截读取属性的行为的例子。要使Proxy起作用，必须针对Proxy实例进行操作，而不是针对目标对象（target）进行操作。\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<hr>\n","text":"ES6 新增详解let 声明变量和 const 声明常量，两个都有块级作用域ES5中是没有块级作用域的，并且var有变量提升，在let中，使用的变量一定要进行声明 箭头函数ES6中的函数定义不再使用关键字function()，而是利用了()&#x3D;&gt;来进行定义 特点：箭...","link":"","photos":[],"count_time":{"symbolsCount":"3.9k","symbolsTime":"4 mins."},"categories":[{"name":"web前端","slug":"web前端","count":3,"path":"api/categories/web前端.json"}],"tags":[{"name":"ES6笔记","slug":"ES6笔记","count":2,"path":"api/tags/ES6笔记.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#ES6-%E6%96%B0%E5%A2%9E%E8%AF%A6%E8%A7%A3\"><span class=\"toc-text\">ES6 新增详解</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#let-%E5%A3%B0%E6%98%8E%E5%8F%98%E9%87%8F%E5%92%8C-const-%E5%A3%B0%E6%98%8E%E5%B8%B8%E9%87%8F%EF%BC%8C%E4%B8%A4%E4%B8%AA%E9%83%BD%E6%9C%89%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F\"><span class=\"toc-text\">let 声明变量和 const 声明常量，两个都有块级作用域</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">箭头函数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2\"><span class=\"toc-text\">模板字符串</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC\"><span class=\"toc-text\">解构赋值</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#for-%E2%80%A6-of%E2%80%A6%E5%BE%AA%E7%8E%AF\"><span class=\"toc-text\">for … of…循环</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#import%E3%80%81export-%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA\"><span class=\"toc-text\">import、export 导入导出</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#set-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">set 数据结构</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E2%80%A6-%E5%B1%95%E5%BC%80%E8%BF%90%E7%AE%97%E7%AC%A6\"><span class=\"toc-text\">… 展开运算符</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BA%94%E7%94%A8-%E3%80%90%E5%90%88%E5%B9%B6%E6%95%B0%E7%BB%84%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E6%95%B0%E7%BB%84%E3%80%81%E7%B1%BB%E6%95%B0%E7%BB%84%E8%BD%AC%E6%95%B0%E7%BB%84%E3%80%81%E4%BD%BF%E7%94%A8-Math-%E5%87%BD%E6%95%B0%E5%88%A4%E6%96%AD%E6%9C%80%E5%A4%A7%E6%9C%80%E5%B0%8F%E3%80%91\"><span class=\"toc-text\">应用 【合并数组、浅拷贝数组、类数组转数组、使用 Math 函数判断最大最小】</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BF%AE%E9%A5%B0%E5%99%A8-%E3%80%90%E6%AF%94%E5%A6%82-vue-%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6-%E4%BB%A3%E6%9B%BF-v-on-%E3%80%91\"><span class=\"toc-text\">修饰器 @ 【比如 vue 的事件修饰符 代替 v-on:】</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#class-%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF\"><span class=\"toc-text\">class 类的继承</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ES6-%E4%B8%AD%E4%B8%8D%E5%86%8D%E5%83%8F-ES5-%E4%B8%80%E6%A0%B7%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%EF%BC%8C%E8%80%8C%E6%98%AF%E5%BC%95%E5%85%A5-Class-%E8%BF%99%E4%B8%AA%E6%A6%82%E5%BF%B5-extends%E3%80%90%E7%BB%A7%E6%89%BF%E3%80%91\"><span class=\"toc-text\">ES6 中不再像 ES5 一样使用原型链实现继承，而是引入 Class 这个概念 extends【继承】</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#promise\"><span class=\"toc-text\">promise</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Symbol\"><span class=\"toc-text\">Symbol</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Map\"><span class=\"toc-text\">Map</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Proxy-%E4%BB%A3%E7%90%86\"><span class=\"toc-text\">Proxy 代理</span></a></li></ol></li></ol>","author":{"name":"LCS's Blog","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一位正在重塑知识的技术人 <br /> @a <h3>加油！！！</h3>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"关于vue2","uid":"3324d7472bb09e978be8ffc008c4f887","slug":"关于vue的学习笔记","date":"2022-12-26T13:14:11.605Z","updated":"2022-12-26T13:14:11.605Z","comments":true,"path":"api/articles/关于vue的学习笔记.json","keywords":null,"cover":[],"text":"MVVM 的理解 MVVM` 表示的是 `Model-View-ViewModel 1：MVVM 是Model-View-ViewModel 的缩写，它是一种基于前端开发的架构模式。 2：其核心是提供对View 和 ViewModel 的双向数据绑定，这使得ViewModel 的...","link":"","photos":[],"count_time":{"symbolsCount":"40k","symbolsTime":"36 mins."},"categories":[{"name":"Vue","slug":"Vue","count":3,"path":"api/categories/Vue.json"}],"tags":[{"name":"vue2","slug":"vue2","count":1,"path":"api/tags/vue2.json"}],"author":{"name":"LCS's Blog","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一位正在重塑知识的技术人 <br /> @a <h3>加油！！！</h3>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"React小记【Redux】","uid":"60c5a95c0e5d17fc3703202ce808ceda","slug":"React学习总结( 三 ) 【 Redux 系列】","date":"2022-12-26T13:14:11.604Z","updated":"2022-12-26T13:14:11.604Z","comments":true,"path":"api/articles/React学习总结( 三 ) 【 Redux 系列】.json","keywords":null,"cover":[],"text":"React 学习总结( 三 )1.什么是 redux? Web 应用是一个状态机，视图与状态是一一对应的。 所有的状态，保存在一个对象里面。 // Redux是react中进行state状态管理的JS库（并不是react插件），一般是管理多个组件中共享数据状态。这个是和Vuex是...","link":"","photos":[],"count_time":{"symbolsCount":"6.7k","symbolsTime":"6 mins."},"categories":[{"name":"React","slug":"React","count":7,"path":"api/categories/React.json"}],"tags":[{"name":"React笔记","slug":"React笔记","count":7,"path":"api/tags/React笔记.json"}],"author":{"name":"LCS's Blog","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一位正在重塑知识的技术人 <br /> @a <h3>加油！！！</h3>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}