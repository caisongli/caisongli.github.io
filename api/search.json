[{"id":"f2200233214eb9075c586fefd73cbdb6","title":"js常用数组方法总结","content":"好用的css属性\n position: sticky：黏性定位\n :empty选择器：容器为空提示文字\n gap：flex元素间隔设置\n background-clip: text：可以做一个带背景的文字效果\n user-select：禁用光标选中 ，让网页看着和移动端一样\n :invalid 伪类：让 input 当值有效时，元素颜色为绿色，无效时为红色\n :focus-within 伪类：一个元素获得焦点，或该元素的后代元素获得焦点，就会匹配上\n mix-blend-mode:difference：描述了元素的内容应该与元素的直系父元素的内容和元素的背景如何混合\n\n具体使用点击以下链接⬇️⬇️⬇️好用的css属性🔗\n数组常用方法【增】\npush()【改变原数组】\npush()方法接收任意数量的参数，并将它们添加到数组末尾，返回数组的最新长度\nunshift()【改变原数组】\nunshift()在数组开头添加任意多个值，然后返回新的数组长度\nsplice()【改变原数组】\n传入三个参数，分别是开始位置、0（要删除的元素数量）、插入的元素，返回空数组\nconcat()【不改变原数组】\n首先会创建一个当前数组的副本，然后再把它的参数添加到副本末尾，最后返回这个新构建的数组，不会影响原始数组，二维数组的话会解构一层；\n在没有concat（）方法，传递参数的情况下，它只是复制当前数组并返回副本。\n\n【删】\npop()【改变原数组】pop() 方法用于删除数组的最后一项，同时减少数组的length 值，返回被删除的项\nshift()【改变原数组】shift()方法用于删除数组的第一项，同时减少数组的length 值，返回被删除的项\nsplice()【改变原数组】传入两个参数，分别是开始位置，删除元素的数量，返回包含删除元素的数组\nslice()【不改变原数组】slice() 用于创建一个包含原有数组中一个或多个元素的新数组，不会影响原始数组\n  let colors = [\"red\", \"green\", \"blue\", \"yellow\", \"purple\"];\n  let colors2 = colors.slice(1);\n  let colors3 = colors.slice(1, 4);\n  console.log(colors)   // red,green,blue,yellow,purple\n  concole.log(colors2); // green,blue,yellow,purple\n  concole.log(colors3); // green,blue,yellow\n\n【改】\nsplice()【改变原数组】传入三个参数，分别是开始位置，要删除元素的数量，要插入的任意多个元素，返回删除元素的数组，对原数组产生影响\n  let colors = [\"red\", \"green\", \"blue\"];\n  let removed = colors.splice(1, 1, \"red\", \"purple\"); // 插入两个值，删除一个元素\n  console.log(colors); // red,red,purple,blue\n  console.log(removed); // green，只有一个元素的数组\nfill()  fill() 方法用于将一个固定值替换数组的元素。\n参数：value 必须，填充的值\n​start 可选，开始填充的位置\n​end 可选，停止填充的位置，默认为array.length\n\n【查】\nindexOf()||lastindexof()反向\n返回要查找的元素在数组中的位置，如果没找到则返回-1\n接收两个参数:要查找的项和（可选的）表示查找起点位置的索引，其中，从数组的开头（位置0）开始向后查找(从前往后找)\n  let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];\n  numbers.indexOf(4) // 3\nincludes(searchElement[,fromIndex])\n返回要查找的元素在数组中的位置，找到返回true，否则false\nfromIndex 从该索引处开始查找 searchElement。如果为负值，则按升序从 array.length + fromIndex 的索引开始搜索。默 认为 0。\nfind((el,index.array)=&gt;{})\nfind() 方法返回通过测试（函数内判断）的数组的第一个元素的值。\n当数组中的元素在测试条件时返回 true 时, find() 返回符合条件的元素，之后的值不会再调用执行     数。\n如果没有符合条件的元素返回 undefined\nfind() 对于空数组，函数是不会执行的.\nfindIndex((el,index.array)=&gt;{})\nfindIndex() 方法返回传入一个测试条件（函数）符合条件的数组第一个元素位置索引。\n如果没有符合条件的元素返回 -1\n【迭代方法】\nsome()\n对数组每一项都运行传入的函数，如果有一项函数返回 true ，则这个方法返回 true，反之为 false\nevery()\n对数组每一项都运行传入的函数，如果对每一项函数都返回 true ，则这个方法返回 true,反之为 false\nforEach()\n对数组每一项都运行传入的函数，没有返回值\nfilter()\n对数组每一项都运行传入的函数，函数返回 true 的项会组成数组之后返回\nmap()\n对数组每一项都运行传入的函数，返回由每次函数调用的结果构成的数组\nlet numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];\nlet mapResult = numbers.map((item, index, array) => item * 2);\nconsole.log(mapResult) // 2,4,6,8,10,8,6,4,2\nkeys()、values()、entries()\nkeys()是对键名的遍历、values()对键值的遍历、entries()是对键值对的遍历。\n【排序方法】\nreverse()【原数组改变】\n数组反向排列\n  let values = [1, 2, 3, 4, 5];\n  values.reverse();\n  alert(values); // 5,4,3,2,1\nsort()【原数组改变】\nsort() 方法用于对数组的元素进行排序。\n数组在原数组上进行排序，不生成副本。\n升序：let arr = [1,22,11,2,4]\narr.sort(function (a,b) &#123;\n  return a-b\n&#125;)\n降序：let arr = [1,22,11,2,4]\narr.sort(function (a,b) &#123;\n  return b-a\n&#125;)\n对象根据某个属性排序：\n let arr = [\n  &#123;name:\"张\",age:20&#125;,\n  &#123;name:\"刘\",age:18&#125;,\n  &#123;name:\"理想\",age:30&#125;\n]\nfunction objectSort(property) &#123;\n  return function (Obj1,Obj2) &#123;\n        return Obj1[property]-Obj2[property]\n  &#125;\n&#125;\narr.sort(objectSort(\"age\"))\nfilter()\n对数组每一项都运行传入的函数，函数返回 true 的项会组成数组之后返回\n【转换方法】\njoin()\njoin() 方法接收一个参数，即字符串分隔符，返回包含所有项的字符串\nlet colors = [\"red\", \"green\", \"blue\"];\nalert(colors.join(\",\")); // red,green,blue\nalert(colors.join(\"||\")); // red||green||blue\n\n","slug":"js内容","date":"2023-03-05T15:19:08.561Z","categories_index":"js摘记","tags_index":"JavaScript","author_index":"LCS's Blog"},{"id":"183e0653004a9419c453246ded3121c2","title":"VSCode快捷键[mac]","content":"Mac VSCode 快捷键\n全局\nCommand + Shift + P 显示命令面板\nCommand + P 快速打开\nCommand + Shift + N 打开新窗口\nCommand + W 关闭窗口\nCommand + , 打开用户设置\nCommand + K Command + S 显示快捷方式\n\n基本\nCommand + X 剪切（未选中文本的情况下，剪切光标所在行）\nCommand + C 复制（未选中文本的情况下，复制光标所在行）\nOption + ↑ 向上移动行\nOption + ↓ 向下移动行\nOption + Shift + ↑ 向上复制行\nOption + Shift + ↓ 向下复制行\nCommand + Shift + K 删除行\nCommand + Enter 下一行插入\nCommand + Shift + Enter 上一行插入\nCommand + Shift + \\ 跳转到匹配的括号\nCommand + [ 减少缩进\nCommand + ] 增加缩进\nCommand + Shift + [ 切换到上一个已打开文件标签\nCommand + Shift + ] 切换到下一个已打开文件标签\nControl + - 切换到上一个已打开文件标签\nControl + Shift + - 切换到下一个已打开文件标签\nCommand + K Command + 0 折叠全部代码块(这个是数字，不是字母。0是代码折叠级别，同理可以换用1，2，3等)\nCommand + K Command + J 展开全部代码块\nCommand + K Command + C 添加行注释\nCommand + / 添加、移除行注释\nOption + Shift + A 添加、移除块注释\nCommand + Shift + D 复制光标所在整行，插入在该行之前\nCommand + K U 选中单词改为大写\nCommand + K L 选中单词改为小写\nCommand + Option + [ 代码折叠\nCommand + Option + ] 代码展开\n\n多光标与选择Command + ↑ 跳转至文件开头\nCommand + ↓ 跳转至文件结尾\nCommand + 点击 插入多个光标\nOption + 左键按住不放，拖动鼠标 添加多个光标\nCommand + U 撤销上一个光标操作\nOption + Shift + I 在所选行的行尾插入光标\nControl + Shift +↑ 向上面一行添加游标\nControl + Shift + ↓ 向下面一行添加游标\nCommand + J 删除当前行与下一行内容合并成一行（光标未选中多行内容的时候） 或 将多行内容合并成一行（已选择需要合并的多行时）\nOption + Shift +↑ 向上复制一行\nOption + Shift + ↓ 向下复制一行\nOption + → 以单词为单位向后移动光标\nOption + Shift + → 以单词为单位向后选中文本\nCommand + K R 在资源管理器中显示活动文件\n\n查找与替换Command + F 查找\nCommand + Option + F 替换\nCommand + Shift + F 在当前文件中查找查找\nCommand + Shift + H 在文件夹中查找替换\nCommand + G 查找下一个\nCommand + Shift + G 查找上一个\nOption + Enter 选中所有匹配项\nCommand + D 向下选中相同内容\nCommand + K Command + D 移除前一个向下选中相同内容\n\n\n进阶Option + Shift + F 格式化代码\nCommand + L 选中当前行SHIFT + ALT + F 格式化代码\nCommand + K Command + F 格式化选择部分\nCommand + K Command + X 删除行尾多余空格\nCommand + kk \\ Control + kk 删除光标至当前行尾内容\n\n导航Control + R 跳转到当前文件的某一符号位置\nControl + G 跳转至某行\nCommand + P 跳转到某个文件\nCommand + M 光标移动至括号内开始或结束的位置\nCommand + Shift + O 跳转到某个符号\nCommand + Shift + M 打开问题面板\n\n编辑器管理Command + W 关闭编辑器\nCommand + \\ 编辑器分屏\nCommand + 1 切换到第一分组\nCommand + 2 切换到第二分组\nCommand + 3 切换到第三分组\nCommand + K Left 激活左侧编辑组\nCommand + K Right 激活右侧编辑组\nCommand + K Z 切换禅模式\n\n文件管理Command + N 新建文件\nCommand + O 打开文件\nCommand + S 保存文件\nCommand + Shift + S 另存为\nCommand + Option + S 全部保存\nCommand + W 关闭\nCommand + K Command + W 全部关闭\nCommand + Shift + T 重新打开被关闭的编辑器\nControl + Tab 打开下一个\nControl + Shift + Tab 打开上一个\nCommand + K R 在资源管理器中查看当前文件\nCommand + K O 新窗口打开当前文件\n\n调试Command + Shift + D 调试\nCommand + Shift + X 安装插件\n\n显示Command + Ctrl + F 全屏、退出全屏\nCommand + + 放大\nCommand + - 缩小\nCommand + B 显示、隐藏侧边栏\nCommand + Shift + F 显示搜索框\nCommand + Shift + X 显示插件面板\nCommand + Shift + H 全局搜索替换\nCommand + Shift + J 显示、隐藏高级搜索\nCommand + Shift + U 显示、隐藏输出面板\n\n集成终端Control + 显示终端 Control + Shift + 新建终端\nCommand + Shift + U 输出\nCommand + Shift + Y 调试控制台\n\nsettings.json&#123;\n    //主题设置\n    \"workbench.colorTheme\": \"Monokai\",\n    // 默认编辑器字号\n    \"editor.fontSize\": 14,\n    //是否自动换行 \n    \"editor.wordWrap\": \"on\",\n    // tab几个缩进\n    \"editor.tabSize\": 2,\n    // 文件自动保存\n    \"files.autoSave\": \"afterDelay\",\n    // 自动格式化粘贴的代码\n    \"editor.formatOnPaste\": true,\n    // 在资源管理器删除内容时候是否进行用户提醒\n    \"explorer.confirmDelete\": false,\n    // 控制在资源管理器内拖放移动文件或文件夹时是否进行确认\n    \"explorer.confirmDragAndDrop\": false,\n    // 在资源管理器拖拽文件是否进行用户提醒\n    \"workbench.statusBar.visible\": true,\n    // 工作区缩放级别\n    \"window.zoomLevel\": 0,\n    // 重命名或移动文件时，启用或禁用自动更新导入路径\n    \"javascript.updateImportsOnFileMove.enabled\": \"always\",\n    // 启用/禁用导航路径\n    \"breadcrumbs.enabled\": true,\n    // 终端cmd字号\n    \"terminal.integrated.fontSize\": 16,\n    // 不检查缩进，保存后统一按设置项来设置\n    \"editor.detectIndentation\": false,\n    // 编辑器初始界面\n    \"workbench.startupEditor\": \"newUntitledFile\",\n    // 工作台状态栏是否可见\n    \"workbench.statusBar.feedback.visible\":false,\n    // 添加多个光标时候需要的快捷键\n    \"editor.multiCursorModifier\": \"ctrlCmd\",\n    // 自定义代码片段显示的位置\n    \"editor.snippetSuggestions\": \"top\",\n    \"window.menuBarVisibility\": \"toggle\",\n    // 启用后，按下 TAB 键，将展开 Emmet 缩写。\n    \"emmet.triggerExpansionOnTab\": true,\n    // 控制编辑器在空白字符上显示符号的方式\n    \"editor.renderWhitespace\": \"all\",\n    // 控制编辑器是否应呈现空白字符\n    \"editor.renderControlCharacters\": false,\n    // 在文件和文件夹上显示错误和警告\n    \"problems.decorations.enabled\": false,\n    // html文件格式化程序\n    \"[html]\": &#123;\n        \"editor.defaultFormatter\": \"vscode.html-language-features\",\n        \"editor.codeActionsOnSave\": &#123;\n          // 禁止eslint对html进行校验\n          \"source.fixAll.eslint\": false,\n          // 禁止stylelint对html进行校验\n          \"source.fixAll.stylelint\": false\n        &#125;\n    &#125;,\n    // 编辑器文件保存时的操作(MacOS：快捷键是 command + s ),并不能修复所有问题，多数还是需要手动修复\n    // \n    \"editor.codeActionsOnSave\": &#123;\n      // 文件保存时开启eslint自动修复程序\n      \"source.fixAll.eslint\": true,\n      // 文件保存时开启stylelint自动修复程序\n      \"source.fixAll.stylelint\": true\n    &#125;,\n    // \"[javascript]\": &#123;\n    //     \"editor.defaultFormatter\": \"vscode.typescript-language-features\"\n    // &#125;,\n\n    // vscode-fileheader  -----settings begin-----\n\n    // 文件作者\n    \"fileheader.Author\": \"xxx\",\n    // 文件最后修改者\n    \"fileheader.LastModifiedBy\": \"xxx\",\n    \n    // vscode-fileheader  -----settings end-----\n\n    \n    //stylelint   -----settings begin-----\n    \n    // 防止编辑器内置linter与插件冲突设置\n    \"css.validate\": false,\n    \"less.validate\": false,\n    \"scss.validate\": false,\n    // 启用stylelint插件\n    \"stylelint.enable\": true,\n\n    //stylelint   -----settings end-----\n\n    // eslint   -----settings begin-----\n\n    // 是否为JavaScript文件开启eslint检测\n    \"eslint.enable\": true,\n    // 保存之后进行lint\n    \"eslint.run\": \"onSave\",\n    // 是否启用eslint的调试模式\n    \"eslint.debug\": true\n    // eslint   -----settings end-----\n    \n&#125;\n\n\n\n","slug":"vscode快捷键与配置","date":"2023-01-29T07:41:12.625Z","categories_index":"编码工具实用干货","tags_index":"VSCode","author_index":"LCS's Blog"},{"id":"adae1d78a6d22cbcc84e90a45ad047a3","title":"前端学习笔记","content":"\n    \n\nhtml 部分1. 　 DOCTYPE 　有什么作用？告诉浏览器使用哪个版本的 HTML 规范来渲染文档。DOCTYPE 不存在或形式不正确会导致 HTML 文档以混杂模式呈现。\n2.页面导入样式时，使用 link 和 @import 有什么区别？link 引用 CSS 时候，页面载入时同时加载；\n@import 需要在页面完全加载以后加载，而且@import 被引用的 CSS 会等到引用它的CSS 文件被加载完才加载\n3.请写出 HTML 块元素标签、行内元素标签、空(void)元素有那些？\n 块级元素标签： 　 div p ul li table h1 … h6 form 等\n 行内元素标签： 　span a i label img input button textarea select 等\n 空(void)元素： 　br    等\n\n4.HTML5 的文件离线储存怎么使用？在页面头部加入 manifest 属性\n&lt;html manifest=\"cache.manifest\">&lt;/html>\n\n5. SVG 与 CanvasSVG 表示（scalable vector graphics）可缩放矢量图形。Canvas 画布\nSVG：通过使用 SVG 绘制的任意形状都可以被记住和操作，并且浏览器可以再次渲染它Canvas:画布则是绘制然后遗忘。一旦绘制完成，你就不能访问和处理像素。\n6.请用 html 知识解决 seo 优化问题？&lt;meta name=\"title\" content=\"html对SEO的优化\" />/*不推荐用这个*/\n&lt;meta name=\"keywords\" content=\"SEO,爬虫，搜索引擎、百度、html优化\" />\n增加关键词搜索\n&lt;meta\n  name=\"description\"\n  content=\"通过html标签及属性的使用提高网站被爬虫爬取的几率，使用户百度时网站尽量排在前面，提高用户的点击率\"\n/>\n添加描述\n\n7.常用浏览器有哪些，内核都是什么，内核的理解？常用浏览器有 IE 火狐(firefox) chrome safari 360 搜狗 等\n\nIE 的是 Trident\n火狐的是 Gecko\nchrome 和 safari 用的是 Webkit\n360 和搜狗这些分极速模式和兼容模式，极速模式用的 Webkit 的内核，兼容模式用的 Trident 内核\n\n浏览器内核主要分成两部分：渲染引擎(Layout Engine或Rendering Engine) 和 JS 引擎。\n8.渐进增强 (progressive enhancement) 和优雅降级 (graceful degradation) 的区别?\n渐进增强: 先保证低版本浏览器的基本功能，再去兼容高版本浏览器效果和交互。\n优雅降级: 先保证高版本浏览器的效果和交互等，再去兼容低版本的浏览器。\n\n9.什么是 FOUC（文档样式短暂失效）?\n原理：当样式表晚于结构性 html 加载，当加载到此样式表时，页面将停止之前的渲染。此样式表被下载和解析后，将重新渲染页面，也就出现了短暂的花屏现象。( 使用@import 方法导入样式表)\n解决方法：使用 link 标签加载 CSS 样式文件。因为 link 是顺序加载的，这样页面会等到 CSS 下载完之后再下载 HTML 文件，这样先布局好，就不会出现 FOUC 问题。\n\n10.Cookie，sessionStorage 和 localStorage 的区别？共同点：都是保存在浏览器端，且是同源的。\n存储位置不同：cookie 在浏览器和服务器间来回传递，而 sessionStorage 和 localStorage 不会自动把数据发给服务器，仅在本地保存。\n存储大小的限制不同：cookie 保存的数据很小，不能超过 4k，而 sessionStorage 和localStorage 保存的数据大，可达到 5M。\n数据的有效期不同：cookie 在设置的 cookie 过期时间之前一直有效，即使窗口或者浏览器关闭。sessionStorage 仅在浏览器窗口关闭之前有效。localStorage 始终有效，窗口和浏览器关闭也一直保存，用作长久数据保存。\n作用域不同：cookie 在所有的同源窗口都是共享；sessionStorage 不在不同的浏览器共享，即使同一页面；localStorage 在所有同源窗口都是共享。\nindexedDB 介绍indexedDB 是一个前端数据持久化解决方案（即前端缓存），由浏览器实现。\n特点:1.存储量大，理论上不封顶\n2.同源策略是一样的\n3.多数api采用的都是异步的方式，防止数据量大的时候阻塞其他的一些操作\n4.通过对象仓库存储的方式\n5.存储的类型比较丰富\n6.能够为数据建立索引，提供查找性能\n\n1.对象仓库，在indexedDB中是没有表的概念的，而是objectStore，一个数据库中可以包含多个objectStore，它是一个灵活的数据结构可以存放多种类型数据，里面储存的每条数据都和一个键相关联。键值可以指定也可以用数字递增也可以不指定但存储的类型会有差异。\n\n2.事务性， 每次操作数据库都必须创建一个事务，2个参数（表名，是否可读写） db.transaction(storeName, ‘readwrite’)\n\n3.基于请求，异步，indexedDB打开数据库，新建表等都是基于请求的，是一种异步的处理方式，必须在他回调函数中处理\n\n11.如何实现浏览器内多个标签页之间的通信? / WebSocket、SharedWorker\n\n//可以调用 localstorge、cookie 等本地存储方式。localstorge 在另一个浏览上下文里被添加、修改或删除时，它都会触发一个事件，我们通过监听事件，控制它的值来进行页面信息通信。\n\n12.什么是渐进式渲染？\n渐进式渲染是用于提高网页性能（尤其是提高用户感知的加载速度），以尽快呈现页面的技术。\n\n在以前互联网带宽较小的时期，这种技术更为普遍。如今，移动终端的盛行，而移动网络往往不稳定，渐进式渲染在现代前端开发中仍然有用武之地。\n\n\n比如：\n//（1）图片懒加载——页面上的图片不会一次性全部加载。当用户滚动页面到图片部分时，JavaScript将加载并显示图像。\n//（2）确定显示内容的优先级（分层次渲染）——为了尽快将页面呈现给用户，页面只包含基本的最少量的CSS、脚本和内容，然后可以使用延迟加载脚本或监听DOMContentLoaded/load事件加载其他资源和内容。\n'（3）异步加载HTML片段——当页面通过后台渲染时，把HTML拆分，通过异步请求，分块发送给浏览器。\n\ncss3 部分1. CSS3 有哪些新特性？RGBA 和 透明度\nbackground-image background-origin(content-box&#x2F;padding-box&#x2F;border-box) background-size background-repeat\nword-wrap（对长的不可分割单词换行）word-wrap：break-word\n文字阴影：text-shadow： 5px 5px 5px #FF0000;（水平阴影，垂直阴影，模糊距离，阴影颜色）\nfont-face 属性：定义自己的字体\n圆角（边框半径）：border-radius 属性用于创建圆角\n边框图片：border-image: url(border.png) 30 30 round\n盒阴影：box-shadow: 10px 10px 5px #888888\n媒体查询：定义两套css，当浏览器的尺寸变化时会采用不同的属性\n\n2.解释一下 Flexbox (弹性盒布局模型)？及适用场景？\n一个容器默认有两条轴，一个是水平的主轴，一个是与主轴垂直的交叉轴。\n\n属性：\nflex-direction 定义主轴的方向；\nflex-wrap 定义是否换行；\nflex-flow 上述2个属性的简写；\njustify-content 定义项目在主轴上的对齐方式；\nalign-items 定义项目在交叉轴上如何对齐；\nalign-content 定义多根轴线的对齐方式\n\n\n3.CSS3 新增伪类有那些?'p:first-of-type 选择属于其父元素的首个元素\n'p:last-of-type 选择属于其父元素的最后元素\n'p:only-of-type 选择属于其父元素唯一的元素\n//p:only-child 选择属于其父元素的唯一子元素\n//p:nth-child(2) 选择属于其父元素的第二个子元素\n:enabled :disabled 表单控件的禁用状态。\n:checked 单选框或复选框被选中。\n\n4.为什么要清除浮动？清除浮动的方式\n清除浮动是为了清除使用浮动元素产生的影响：浮动的元素，高度会塌陷，而高度的塌陷使我们页面后面的布局不能正常显示。\n\n1/* 万能清除浮动代码*/  2 /*在结尾处添加空div标签 clear:both*/  3/*父级div定义height*/ 4 /*父级div定义 overflow:hidden 或 overflow:auto*/\n//.clearfloat:after&#123;\n\tdisplay:block;\n\tclear:both;\n\tcontent:\"\";\n\tvisibility:hidden;\n\theight:0;\n&#125;\n//.clearfloat&#123;\n\tzoom:1;\n&#125;\n\n5.::before 和 :after 中双冒号和单冒号有什么区别？解释一下这 2 个伪元素的作用\n单冒号( : )用于 CSS3 伪类，双冒号( :: )用于 CSS3 伪元素。\n\n::before 就是以一个子元素的存在，定义在元素主体内容之前的一个伪元素。并不存在于dom之中，只存在于页面之中。\n//:before 和 :after 这两个伪元素，是在 CSS2.1 里新出现的。起初，伪元素的前缀使用的是单冒号语法，但随着Web的进化，在CSS3的规范里，伪元素的语法被修改成使用双冒号，成为 ::before ::after。\n\n6.让页面里的字体变清晰，变细用 CSS 怎么做？\n-webkit-font-smoothing 在 window 系统下没有起作用，但是在 IOS 设备上起作用\n-webkit-font-smoothing：antialiased 是最佳的，灰度平滑。\n\n7.如果需要手动写动画，你认为最小时间间隔是多久，为什么？//多数显示器默认频率是 60Hz，即1秒刷新60次，所以理论上最小间隔为1/60＊1000ms ＝ 16.7ms。\n\n8.什么是响应式设计？响应式设计的基本原理是什么？响应式网站设计(Responsive Web design)是一个网站能够兼容多个终端，而不是为每一个终端做一个特定的版本。\n基本原理是通过媒体查询 @media 检测不同的设备屏幕尺寸做处理。\n\n9.Sass、Less 是什么？大家为什么要使用他们？/他们是CSS预处理器。是CSS上的一种抽象层。它们是一种特殊的语法、语言编译成CSS。\n\n' Less 是一种动态样式语言。将CSS赋予了动态语言的特性，如变量，继承，运算，函数。Less即可以在客户端上运行（支持IE6+,Webkit,Firefox），也可以在服务端运行（借助Node.js）。\n//Sass 变量必须是 $ 开始，而 Less 变量必须使用 @ 符号开始。\n为什么要使用它们？\n\n//结构清晰，便于扩展。\n//可以方便地屏蔽浏览器私有语法差异。（这个不用多说，封装对浏览器语法差异的重复处理，减少无异议的机械劳动。）\n//可以轻松实现多重继承。\n//完全兼容CSS代码，可以方便地应用到老项目中。Less 只是在CSS语法上做了扩展，所以老的CSS代码也可以与 Less 代码一同编译。\n\n10.display:inline-block 什么时候会显示间隙？//有空格时候会有间隙——解决：移除空格\n//margin 正值的时候——解决：margin使用负值\n//使用 font-size 时候——解决：font-size:0、letter-spacing、word-spacing\n\n11.浏览器是怎样解析 CSS 选择器的？/CSS选择器的解析是从右向左解析的。\n\n'若从左向右的匹配，发现不符合规则，需要进行回溯，会损失很多性能。\n//若从右向左匹配，先找到所有的最右节点，对于每一个节点，向上寻找其父节点直到找到根元素或满足条件的匹配规则，则结束这个分支的遍历。\n'两种匹配规则的性能差别很大，是因为从右向左的匹配在第一步就筛选掉了大量的不符合条件的最右节点（叶子节点），而从左向右的匹配规则的性能都浪费在了失败的查找上面。\n//而在 CSS 解析完毕后，需要将解析的结果与 DOM Tree 的内容一起进行分析建立一棵 Render Tree，最终用来进行绘图。在建立 Render Tree 时（WebKit 中的Attachment过程），浏览器就要为每个 DOM Tree 中的元素根据 CSS 的解析结果（Style Rules）来确定生成怎样的 Render Tree。\n\n12. CSS 优化、提高性能的方法有哪些？'避免过度约束\n'避免后代选择符\n'避免链式选择符\n'使用紧凑的语法\n'避免不必要的命名空间\n'避免不必要的重复\n'最好使用表示语义的名字。一个好的类名应该是描述他是什么而不是像什么\n'避免 !important，可以选择其他选择器\n'尽可能的精简规则，你可以合并不同类里的重复规则\n\n13.阐述一下 CSS Sprites（雪碧图）//将一个页面涉及到的所有图片都包含到一张大图中去，然后利用CSS的 background-image，background- repeat，background-position 的组合进行背景定位。\n//利用CSS Sprites能很好地减少网页的http请求，从而大大的提高页面的性能；CSS Sprites能减少图片的字节。\n\n14.移动端的布局用过媒体查询吗？通过媒体查询可以为不同大小和尺寸的媒体定义不同的 css，适应相应的设备的显示。\n&lt;head>\n  里边引入： &lt;link rel=”stylesheet” type=”text/css” href=”xxx.css” media=”only\n  screen and (max-device-width:480px)”> 1 CSS中定义： @media only screen and\n  (max-device-width:480px) &#123; /* css样式 */ &#125;\n&lt;/head>\n\n15.上下 margin 重合的问题?在重合元素外包裹一层容器，通过改变此div的属性使两个盒子分属于两个不同的BFC，以此来阻止margin重叠。\n\njs 部分1、0.1 + 0.2 === 0.3 ？为什么？false精度丢失可能出现在进制转换和对阶运算中\n在两数相加时，会先转换成二进制，0.1 和 0.2 转换成二进制的时候尾数会发生无限循环，然后进行对阶运算，JS 引擎对二进制进行截断，所以造成精度丢失。\n2、JS 数据类型//基本类型：Number、Boolean、String、null、undefined、symbol（ES6 新增的），BigInt（ES2020）\n\n//引用类型：Object，对象子类型（Array，Function）\n\n'扩展：symbol 有什么用处？\n\n//可以用来表示一个独一无二的变量防止命名冲突。\n还可以利用 symbol 不会被常规的方法（除了 Object.getOwnPropertySymbols 外）遍历到，所以可以用来模拟私有变量。\n//主要用来提供遍历接口，布置了 symbol.iterator 的对象才可以使用 for···of 循环，可以统一处理数据结构。调用之后回返回一个遍历器对象，包含有一个 next 方法，使用 next 方法后有两个返回值 value 和 done 分别表示函数当前执行位置的值和是否遍历完毕。\nSymbol.for() 可以在全局访问 symbol\n\n\n3、如何判断 JS 数据类型一、typeof 【检测除 null 外的基本类型 返回字符串 】\n typeof  返回一个表示数据类型的字符串，返回结果包括：number、string、boolean、object、undefined、function。typeof 可以对基本类型 number、string、boolean、undefined 做出准确的判断（null 除外，typeof null === “object”）；而对于引用类型，除了 function 之外返回的都是 object。但当我们需要知道某个对象的具体类型时，typeof 就显得有些力不从心了。\ntypeof 1; \t// number 有效\ntypeof ‘ ’;\t// string 有效\ntypeof true; // boolean 有效\ntypeof undefined; // undefined 有效\ntypeof null; / object 无效\ntypeof new Function(); // function 有效\ntypeof [] ; / object 无效\ntypeof new Date(); / object 无效\ntypeof new RegExp(); / object 无效\ntypeof NaN;  // number Not a Number，表示非数字\n\n二、instanceof 【检测是否是某个构造函数的实例】\n 当我们需要知道某个对象的具体类型时，可以用运算符 instanceof，instanceof 操作符判断左操作数对象的原型链上是否有右边这个构造函数的 prototype 属性，也就是说指定对象是否是某个构造函数的实例，最后返回布尔值。\n//当 A 的 __proto__ 指向 B 的 prototype 时，就认为A就是B的实例\ninstanceof (A,B) = &#123;\n    var L = A.__proto__; // L是A的原型对象\n    var R = B.prototype; // R是B的原型对象\n    if(L === R) &#123;\n        // A的内部属性__proto__指向B的原型对象\n        return true;\n    &#125;\n    return false;\n&#125;\n\n[] instanceof Array; // true\n[] instanceof Object; // true\nnew Date() instanceof Date; // true\nnew Date() instanceof Object; // true\nfunction Person() &#123;&#125; //创建 Person 构造函数\nnew Person() instanceof Person; // true\nnew Person() instanceof Object; // true\n\n三、constructor 【得知某个实例对象，到底是哪一个构造函数产生的】\n//constructor 属性的作用是，可以得知某个实例对象，到底是哪一个构造函数产生的。\nvar f = new F();\nf.constructor === F;// true\n\n/但是 constructor 属性易变，不可信赖，这个主要体现在自定义对象上，当开发者重写 prototype 后，原有的 constructor 会丢失。\nfunction F() &#123;&#125;\nF.prototype = &#123;\n\t_name: 'Eric',\n&#125;;\nvar f = new F();\nf.constructor === F; // false\n//因此，为了规范，在重写对象原型时一般都需要重新给 constructor 赋值，以保证实例对象的类型不被改写。\n\n四、 Object.prototype.toString 【返回其调用者的具体类型 类型格式为[object,xxx]比较推荐】\ntoString 是 Object 原型对象上的一个方法，该方法默认返回其调用者的具体类型，更严格的讲，是 toString 运行时 this 指向的对象类型，返回的类型格式为[object,xxx]，xxx 是具体的数据类型，其中包括：String，Number，Boolean，Undefined，Null，Function，Date，Array，RegExp，Error，HTMLDocument，… 基本上所有对象的类型都可以通过这个方法获取到。\n\nObject.prototype.toString.call(\"\"); // [object String]\nObject.prototype.toString.call(1); // [object Number]\nObject.prototype.toString.call(true); // [object Boolean]\nObject.prototype.toString.call(undefined); // [object Undefined]\nObject.prototype.toString.call(null); // [object Null]\nObject.prototype.toString.call(new Function()); // [object Function]\nObject.prototype.toString.call(new Date()); // [object Date]\nObject.prototype.toString.call([]); // [object Array]\nObject.prototype.toString.call(new RegExp()); // [object RegExp]\nObject.prototype.toString.call(new Error()); // [object Error]\nObject.prototype.toString.call(document); // [object HTMLDocument]\nObject.prototype.toString.call(window); //[object Window]\n\n总结：typeof 可以准确地判断出基本类型，但是对于引用类型除 function 之外返回的都是 object；\n已知是引用类型的情况可以选用 instanceof 或 constructor 方法进行具体类型的判断：\ninstanceof 是基于原型链的；\n'constructor 属性易变，不可信赖，为了规范，在重写对象原型时一般都需要重新给 constructor 赋值，以保证实例对象的类型不被改写；\n//Object.prototype.toString.call() 通用但很繁琐。\n\n4、事件如何实现的？事件流？事件：\n//基于发布订阅模式，就是在浏览器加载的时候会读取事件相关的代码，但是只有实际等到具体的事件触发的时候才会执行。\n//比如点击按钮，这是个事件（Event），而负责处理事件的代码段通常被称为事件处理程序（Event Handler），也就是「启动对话框的显示」这个动作。\n\n在 Web 端，我们常见的就是 DOM 事件：\n//DOM0 级事件，直接在 html 元素上绑定 on-event，比如 onclick，取消的话，dom.onclick = null，同一个事件只能有一个处理程序，后面的会覆盖前面的。\n//DOM2 级事件，通过 addEventListener 注册事件，通过 removeEventListener 来删除事件，一个事件可以有多个事件处理程序，按顺序执行，捕获事件和冒泡事件。\n//DOM3 级事件，增加了事件类型，比如 UI 事件，焦点事件，鼠标事件等。\n\n事件流\n事件流是网页元素接收事件的顺序，\"DOM2级事件\"规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段。'首先发生的事件捕获'，为截获事件提供机会。  然后是实际的'目标接受事件'。最后一个阶段是'事件冒泡阶段'，可以在这个阶段对事件做出响应。虽然捕获阶段在规范中规定不允许响应事件，但是实际上还是会执行，所以有两次机会获取到目标对象。\n\n5、闭包什么是闭包？ 函数嵌套函数 能够读取其他函数内部变量的函数\n优点： 1、使用闭包是不会污染全局环境，2、方便进行模块化开发，3、可以在内存中维护一个变量\n缺点： 就是不恰当使用会造成内存泄漏 【解决方式：清除变量】\n//闭包原理：定义在一个函数内部的函数(函数嵌套函数)，闭包就是将函数内部和函数外部连接起来的一座桥梁。\n//打破了作用域链的规则 闭包就是能够读取其他函数内部变量的函数\n\n闭包应用场景\n//原生的setTimeout传递的第一个函数不能带参数\nsetTimeout(function (param) &#123;\n  alert(param);\n&#125;, 1000);\n//通过闭包可以实现传参效果\nfunction func(param) &#123;\n  return function () &#123;\n    alert(param);\n  &#125;;\n&#125;\nvar f1 = func(1);\nsetTimeout(f1, 1000); // 1\n\n5、call、apply、bind 的区别相同点：call、apply、bind 的共同点都是为了解决改变 this 的指向。作用都是相同的，只是传参的方式不同。\n不同点：\n//call() 和 apply() 是立即执行的，而 bind() 是返回一个函数。\ncall() '可以传递多个参数'，第一个参数和 apply() 一样，是用来替换的对象，后面是参数列表。\napply() '最多只能有两个参数' —— 新this对象和一个'参数数组或类数组 argArray'\nbind() 和其他两个方法的作用也是一致的，只是该方法会返回一个函数，并且可以'通过bind() 实现柯里化'。\n\n6、什么是 Promise？Promise 是目前 JS 异步编程的一种解决方案\n\n从语法上讲，Promise 是一个对象，从它可以获取异步操作的消息；\n从本意上讲，它是承诺，承诺它过一段时间会给你一个结果。\n\nPromise 原理简析 ：1、Promise 本身相当于一个状态机，拥有三种状态：\n'pending(等待态)\n'fulfiled(成功态)\n'rejected(失败态)\n一个 Promise 对象初始化时的状态是 pending，调用了 resolve 后会将 Promise 的状态扭转为 fulfilled，调用 reject 后会将 Promise 的状态扭转为 rejected，这两种扭转一旦发生便不能再扭转该 Promise 到其他状态。\n\n2、Promise 对象原型上有一个 then 方法，then 方法会返回一个新的 Promise 对象，并且将回调函数 return' 的结果作为该 Promise resolve 的结果'，then 方法会在一个 Promise 状态被扭转为 fulfilled 或 rejected 时被调用。then 方法的'参数为两个函数'，分别为 Promise 对象的状态被扭转为 fulfilled 和 rejected 对应的回调函数。\n\nPromise 使用\n//构造一个 Promise 对象，并将要执行的异步函数传入到 Promise 的参数中执行，并且在异步执行结束后调用 resolve() 函数，就可以在 Promise 的 then 方法中获取到异步函数的执行结果\nPromise.resolve():Promise.resolve 返回一个 fulfilled 状态的 Promise\n'Promise.all([p1,pa,p3,...])\n//Promise.all 接收一个 Promise 对象数组作为参数，只有全部的 Promise 都已经变为 fulfilled 状态后才会继续后面的处理。Promise.all 本身返回的也是一个 Promise;\n'Promise.race([p1,p1,p3,...])\n//Promise.race 和 Promise.all 类似，只不过这个函数会在 Promise 中第一个 promise 的状态扭转后就开始后面的处理（fulfilled、rejected 均可）\n\n7、js 脚本加载问题，async、defer\n正常加载模式\n//这种情况下 JS 会阻塞浏览器，浏览器必须等待前面所有的 js 加载和执行完毕才能去做其它事情\n&lt;script src=\"index.js\">&lt;/script>\nasync(异步) 模式\n//async 模式下，JS 不会阻塞浏览器做任何其它的事情。它的加载是异步的，当它加载结束，JS 脚本会立即执行\n&lt;script async src=\"index.js\">&lt;/script>\ndefer(延缓) 模式\n//defer 模式下，JS 的加载是异步的，执行是被推迟的。等整个文档解析完成、DOMContentLoaded 事件即将被触发时，被标记了 defer 的 JS 文件才会开始依次执行。\n&lt;script defer src=\"index.js\">&lt;/script>\n总结\n//从应用的角度来说，一般当我们的脚本与 DOM 元素和其它脚本之间的依赖关系不强时，我们会选用 async；\n//当脚本依赖于 DOM 元素和其它脚本的执行结果时，我们会选用 defer。\n\n8、获取 url 的 search 部分 【obj = new URL(str) obj2 = new URLSearchParams(str2)】const str =\n  \"https://huodong.taobao.com/wow/a/act/tao/dailyact/4634/wupr?spm=a21bo.jianhua.201867-main.1.5af911d97F6TPV&amp;wh_pid=dailyAct-257518\";\nconst obj = new URL(str);\nconsole.log(obj.searchParams.get(\"wh_pid\"));\n\nconst str2 =\n  \"?spm=a21bo.jianhua.201867-main.1.5af911d97F6TPV&amp;wh_pid=dailyAct-257518\";\nconst obj2 = new URLSearchParams(str2);\nconsole.log(obj2.get(\"wh_pid\"));\n\nconst obj3 = &#123;\n  a: 3,\n  b: 4,\n&#125;;\n","slug":"面试题总结","date":"2022-12-26T13:14:11.606Z","categories_index":"web前端","tags_index":"学习总结","author_index":"LCS's Blog"},{"id":"9a20f08646fc7ae20aeb4af73512aebe","title":"Pinia菠萝——Vue的最新状态存储库","content":"【Pinia 菠萝】——Vue 的最新状态存储库Pinia 是什么?Pinia 是一个用于 Vue 的状态管理库，类似 Vuex, 是 Vue 的另一种状态管理方案       Pinia    支持     Vue2 和 Vue3\nPinia 优势mutations 不再存在,更加简洁直观，减少代码冗余\n不需要嵌套模块，符合 Vue3 的 Composition api ，让代码更加扁平化\n完整的 TypeScript 支持\n非常的轻量级， 仅有 1 KB\n模块化设计，便于拆分状态\n安装 Piniayarn add pinia\n# 或者使用 npm\nnpm install pinia\n\n提示\n如果您的应用使用 Vue 2，您还需要安装组合 API：`@vue/composition-api`。 如果您使用 Nuxt，则应遵循 [这些说明](https://pinia.web3doc.top/ssr/nuxt.html)。\n\n创建一个 pinia（根存储）并将其传递给应用程序：\n// main.js\nimport &#123; createApp &#125; from \"vue\";\nimport App from \"./App.vue\";\nimport &#123; createPinia &#125; from \"pinia\";\nconst pinia = createPinia();\nconst app = createApp(App);\napp.use(pinia);\napp.mount(\"#app\");\n\n创建 store 仓库\nsrc  -  store 文件夹   -  index.js\nimport &#123; defineStore &#125; from \"pinia\";\nexport const store = defineStore(\"Counter\", &#123;\n  state: () => (&#123;\n    count: 1,\n    name: \"郦郦郦\",\n  &#125;),\n  getters: &#123;\n    countPow2(state) &#123;\n      return (state.count + 2) ** 2; // 9 也可以使用this\n    &#125;,\n  &#125;,\n  actions: &#123;\n    add(a, b) &#123;\n      console.log(\"a\", a); // 传过来的参数 2\n      console.log(\"b\", b); // undefined\n      this.$patch(&#123;\n        count: this.count + a,\n      &#125;);\n    &#125;,\n  &#125;,\n&#125;);\n\n组件内使用：&lt;template&gt;\n  &lt;div class&#x3D;&quot;hello&quot;&gt;\n    &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;&#x2F;h1&gt;\n    &lt;p&gt;&#123;&#123; count &#125;&#125;&lt;&#x2F;p&gt;\n    &lt;p&gt;&#123;&#123; name &#125;&#125;&lt;&#x2F;p&gt;\n    &lt;p&gt;&#123;&#123; countPow2 &#125;&#125;&lt;&#x2F;p&gt;\n    &lt;p&gt;&lt;button @click&#x3D;&quot;add&quot;&gt;+&lt;&#x2F;button&gt;&lt;&#x2F;p&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport &#123; store as useCountStore &#125; from &quot;..&#x2F;store&#x2F;index.js&quot;;\nimport &#123; computed &#125; from &quot;vue&quot;;\nexport default &#123;\n  name: &quot;HelloWorld&quot;,\n  props: &#123;\n    msg: String,\n  &#125;,\n  setup() &#123;\n    const store &#x3D; useCountStore();\n    const add &#x3D; () &#x3D;&gt; &#123;\n      store.add(2); &#x2F;&#x2F; 传参\n      store.$patch(&#123;\n        name: (store.name &#x3D; &quot;郦111&quot;),\n      &#125;);\n    &#125;;\n    return &#123;\n      count: computed(() &#x3D;&gt; store.count),\n      countPow2: computed(() &#x3D;&gt; store.countPow2),\n      name: computed(() &#x3D;&gt; store.name),\n      add,\n    &#125;;\n  &#125;,\n&#125;;\n&lt;&#x2F;script&gt;\n\n初始页面：\n\n\n使用仓库 actions 方法后的页面：\n\n\n核心概念Store\nStore 是一个保存状态和业务逻辑的实体，可以自由读取和写入，并通过导入后在 setup 中使用\n\nGetters\nPinia 中的 Getters 作用与 Vuex 中的 Getters 相同，但使用略有差异\nPinia 中的 Getters 直接在 Store 上读取，形似 Store.xx，就和一般的属性读取一样\n基本使用\nGetter 第一个参数是 state，是当前的状态，也可以使用 this.xx 获取状态\nGetter 中也可以访问其他的 Getter， 或者是其他的 Store\n\nactions\nPinia 没有 Mutations，统一在 actions 中操作 state，通过this.xx 访问相应状态\n虽然可以直接操作 Store，但还是推荐在 actions 中操作，保证状态不被意外改变\naction 和普通的函数一样\naction 同样可以像 Getter 一样访问其他的 Store，同上方式使用其它 Store\n\n提示\n在 vue 文件中解构 pinia 中的 state 会出现丢失响应式的问题,可以通过 pinia 出的 storeToRefs 去进行解构可以保持变量的响应式\nimport &#123; storeToRefs &#125; from 'pinia';\nsetup()&#123;\nconst store = useCountStore();\nconst &#123; count &#125; = storeToRefs(store);\nreturn &#123; count &#125;\n&#125;\n\n","slug":"【Pinia菠萝】——Vue最新的状态存储库","date":"2022-12-26T13:14:11.605Z","categories_index":"Vue","tags_index":"Pinia菠萝","author_index":"LCS's Blog"},{"id":"60f5536e92b4df8f10291e74b113744c","title":"Vue性能优化——按需引入第三方组件库","content":"Vue按需引入第三方组件库为什么按需引入组件库?为了能够快速开发，提高开发效率，通常都会引入第三方组件库，当把组件库全部导入项目中，最后打包项目后会发现项目的体积过大。实际情况中，整个项目可能才使用整个组件库40%的组件，而剩下60%不用就显得非常浪费。我们可以将这用到的40%的组件按需引入到项目中，不用的组件则不引入到项目，从而达到减少打包体积，提升项目响应速度的目的。\n项目打包体积对比：\n\ndist.zip为按需引入组件库，使用了些许标签的打包体积，只有392KB\n\ndist(2).zip为组件库全局引入，使用了些许标签的打包结果，却是达到了1.1M\n\n总结：由此可见，按需引入组件库是可以有效减少项目体积的，提高项目线上首屏渲染速度，减少白屏时间，减少流量消耗\n组件按需引入的方法【以arco-design/web-vue组件库为例】1、安装unplugin-vue-components  和  unplugin-auto-import  插件\nyarn add -D unplugin-vue-components unplugin-auto-import\n# 或者使用 npm\nnpm install -D unplugin-vue-components unplugin-auto-import\n\n2、配置vue.config.js文件\nvue-cli内部用的就是webpack，所以configureWebpack配置的会被合并\n自动引入组件与样式，不需在main.js引入\n\nconst &#123; defineConfig &#125; = require('@vue/cli-service');\nconst AutoImport = require('unplugin-auto-import/webpack');\nconst Components = require('unplugin-vue-components/webpack');\nconst &#123; ArcoResolver &#125; = require('unplugin-vue-components/resolvers') //如果是ElementPlus组件库则是ElementPlusResolver\nmodule.exports = defineConfig(&#123;\n  transpileDependencies: true,\n  configureWebpack: &#123;\n    plugins: [\n      AutoImport(&#123;\n        resolvers: [ArcoResolver()]\n      &#125;),\n      Components(&#123;\n        resolvers: [ArcoResolver()]\n      &#125;)\n    ],\n  &#125;\n&#125;)\n\n组件使用：【使用了组件库的Layout、Button、Space、图片轮播 Carousel组件】&lt;template&gt;\n  &lt;div class&#x3D;&quot;layout-demo&quot; style&#x3D;&quot;height: 100vh&quot;&gt;\n    &lt;a-layout style&#x3D;&quot;height: 100%&quot;&gt;\n      &lt;a-layout-header&gt;Header&lt;&#x2F;a-layout-header&gt;\n      &lt;a-layout&gt;\n        &lt;a-layout-sider theme&#x3D;&quot;dark&quot;&gt;Sider&lt;&#x2F;a-layout-sider&gt;\n        &lt;a-layout-content\n          &gt;&lt;div class&#x3D;&quot;hello&quot;&gt;\n            &lt;slot &#x2F;&gt;\n            &lt;router-link to&#x3D;&quot;&#x2F;&quot;&gt;home | &lt;&#x2F;router-link&gt;\n            &lt;router-link to&#x3D;&quot;&#x2F;about&quot;&gt;about&lt;&#x2F;router-link&gt;\n            &lt;slot name&#x3D;&quot;b&quot;&gt;&lt;&#x2F;slot&gt;\n            &lt;h1&gt;哈哈哈&lt;&#x2F;h1&gt;\n            &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;&#x2F;h1&gt;\n            &lt;a-space&gt;\n              &lt;a-button type&#x3D;&quot;primary&quot;&gt;Primary&lt;&#x2F;a-button&gt;\n              &lt;a-button type&#x3D;&quot;dashed&quot;&gt;Dashed&lt;&#x2F;a-button&gt;\n              &lt;a-button type&#x3D;&quot;outline&quot;&gt;Outline&lt;&#x2F;a-button&gt;\n              &lt;a-button type&#x3D;&quot;text&quot;&gt;Text&lt;&#x2F;a-button&gt;\n            &lt;&#x2F;a-space&gt;\n          &lt;&#x2F;div&gt;\n          &lt;div&gt;\n            &lt;a-carousel\n              :style&#x3D;&quot;&#123;\n                width: &#39;600px&#39;,\n                height: &#39;240px&#39;,\n              &#125;&quot;\n              :default-current&#x3D;&quot;2&quot;\n              @change&#x3D;&quot;handleChange&quot;\n              :auto-play&#x3D;&quot;true&quot;\n              animation-name&#x3D;&quot;fade&quot;\n            &gt;\n              &lt;a-carousel-item v-for&#x3D;&quot;image in images&quot; :key&#x3D;&quot;image&quot;&gt;\n                &lt;img\n                  :src&#x3D;&quot;image&quot;\n                  :style&#x3D;&quot;&#123;\n                    width: &#39;100%&#39;,\n                  &#125;&quot;\n                &#x2F;&gt;\n              &lt;&#x2F;a-carousel-item&gt;\n            &lt;&#x2F;a-carousel&gt;\n          &lt;&#x2F;div&gt;\n        &lt;&#x2F;a-layout-content&gt;\n      &lt;&#x2F;a-layout&gt;\n      &lt;a-layout-footer&gt;Footer&lt;&#x2F;a-layout-footer&gt;\n    &lt;&#x2F;a-layout&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport &#123; defineComponent &#125; from &quot;vue&quot;;\nexport default defineComponent(&#123;\n  name: &quot;HelloWorld&quot;,\n  props: &#123;\n    msg: String,\n  &#125;,\n  setup() &#123;\n    const images &#x3D; [\n      &quot;https:&#x2F;&#x2F;p1-arco.byteimg.com&#x2F;tos-cn-i-uwbnlip3yd&#x2F;cd7a1aaea8e1c5e3d26fe2591e561798.png~tplv-uwbnlip3yd-webp.webp&quot;,\n      &quot;https:&#x2F;&#x2F;p1-arco.byteimg.com&#x2F;tos-cn-i-uwbnlip3yd&#x2F;6480dbc69be1b5de95010289787d64f1.png~tplv-uwbnlip3yd-webp.webp&quot;,\n      &quot;https:&#x2F;&#x2F;p1-arco.byteimg.com&#x2F;tos-cn-i-uwbnlip3yd&#x2F;0265a04fddbd77a19602a15d9d55d797.png~tplv-uwbnlip3yd-webp.webp&quot;,\n    ];\n    const handleChange &#x3D; (value) &#x3D;&gt; &#123;\n      console.log(value);\n    &#125;;\n    return &#123;\n      images,\n      handleChange,\n    &#125;;\n  &#125;,\n&#125;);\n&lt;&#x2F;script&gt;\n\n&lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;\n&lt;style scoped&gt;\n.layout-demo :deep(.arco-layout-header),\n.layout-demo :deep(.arco-layout-footer),\n.layout-demo :deep(.arco-layout-sider-children),\n.layout-demo :deep(.arco-layout-content) &#123;\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  color: var(--color-white);\n  font-size: 16px;\n  font-stretch: condensed;\n  text-align: center;\n&#125;\n\n.layout-demo :deep(.arco-layout-header),\n.layout-demo :deep(.arco-layout-footer) &#123;\n  height: 64px;\n  background-color: var(--color-primary-light-4);\n&#125;\n\n.layout-demo :deep(.arco-layout-sider) &#123;\n  width: 206px;\n  &#x2F;* height: calc(100% - 128px); *&#x2F;\n  background-color: var(--color-primary-light-3);\n&#125;\n\n.layout-demo :deep(.arco-layout-content) &#123;\n  background-color: rgb(var(--arcoblue-6));\n&#125;\n&lt;&#x2F;style&gt;\n\n","slug":"【Vue性能优化】——按需引入第三方组件库","date":"2022-12-26T13:14:11.605Z","categories_index":"Vue性能优化","tags_index":"Vue性能优化","author_index":"LCS's Blog"},{"id":"93caf5b8f94c3a6b610b12e797fcd466","title":"判断密码强度","content":"【前端面试题】——判断密码强度（简易版）代码：&lt;body&gt;\n   &lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;input&quot; &#x2F;&gt;\n   &lt;span id&#x3D;&quot;massge1&quot;&gt;&lt;&#x2F;span&gt;\n   &lt;script&gt;\n     let input &#x3D; document.getElementById(&quot;input&quot;);\n     let span &#x3D; document.getElementById(&quot;massge1&quot;);\n     input.addEventListener(&quot;input&quot;, fn);\n     function fn() &#123;\n       const reg &#x3D; [&#x2F;\\d+&#x2F;g, &#x2F;[a-z]+&#x2F;g, &#x2F;[A-Z]+&#x2F;g, &#x2F;[^A-z0-9]+&#x2F;g, &#x2F;^.&#123;8,&#125;$&#x2F;]; &#x2F;&#x2F;验证密码的正则数组\n       const res &#x3D; reg.map((el) &#x3D;&gt; el.test(this.value)); &#x2F;&#x2F;将判断结果组成新数组，5个布尔值\n       const len &#x3D; res.pop(); &#x2F;&#x2F;删除最后一位布尔结果，返回给len，此时res数组只有4个布尔值\n       const count &#x3D; res.reduce((a, b) &#x3D;&gt; a + b); &#x2F;&#x2F;将布尔值相加，求得true的数量，布尔值相加自动转成数字\n       const str &#x3D; &#123;\n         1: &#123;\n           message: &quot;密码必须包含,大小写字母,数字,特殊符号中的至少两种类型&quot;,\n           color: &quot;red&quot;,\n         &#125;,\n         2: &#123; message: &quot;弱&quot;, color: &quot;red&quot; &#125;,\n         3: &#123; message: &quot;中&quot;, color: &quot;yellow&quot; &#125;,\n         4: &#123; message: &quot;强&quot;, color: &quot;green&quot; &#125;,\n       &#125;; &#x2F;&#x2F;创建内容对象\n       if (len) &#123;  &#x2F;&#x2F; 满足8位数后判断密码强度\n         span.textContent &#x3D; str[count].message; &#x2F;&#x2F;根据输入的内容判断内容是否符合\n         span.style.color &#x3D; str[count].color;\n       &#125; else &#123;\n         span.textContent &#x3D; &quot;密码长度需要8位&quot;;\n         span.style.color &#x3D; &quot;red&quot;;\n       &#125;\n     &#125;\n   &lt;&#x2F;script&gt;\n &lt;&#x2F;body&gt;\n\n示例：\n\nps:这只是简易版，写得不好，或者需要补充的地方，请大佬们在评论区指出😊\n","slug":"【前端面试题】——判断密码强度（简易版）","date":"2022-12-26T13:14:11.605Z","categories_index":"js面试题","tags_index":"JavaScript","author_index":"LCS's Blog"},{"id":"efb0492528fda01248e58bf9c3ab3caa","title":"简单的数据转换(二)","content":"【前端面试题】——数据转换二初始数据：const data = &#123; a: &#123; b: 3 &#125;, c: 10, d: [1, 8] &#125;;\n\n转换成：\nconst data = &#123;a.b: 3, c: 10, d[1]: 8&#125;\n\n代码：\nfunction result(obj) &#123;\n  let res = new Map(); // 创建Map,用来存放处理的数据\n  for (let key in obj) &#123;\n    // 开始遍历初始对象\n    if (obj[key].constructor.name === \"Object\") &#123;\n      //如果对象里有对象类型，开始数据转换后存放进map对象\n      for (let j in obj[key]) &#123;\n        res.set(key + \".\" + j, obj[key][j]); // 用new Map().set可以存储数据\n      &#125;\n    &#125; else if (Array.isArray(obj[key])) &#123;\n      // 同理，判断有木有数组类型的，有就进行数据操作\n      for (let k in obj[key]) &#123;\n        res.set(`$&#123;key&#125;[$&#123;obj[key][0]&#125;]`, obj[key][1]); //存放进Map对象\n      &#125;\n    &#125; else &#123;\n      res.set(key, obj[key]); // 啥都没匹配到的数据，原封不动存入\n    &#125;\n  &#125;\n  let obj2 = &#123;&#125;; // 创建一个空对象\n  for (let [key, value] of res) &#123;\n    //Map对象转换成普通对象,Map有iterator迭代器，可以用for of 遍历 [key,value]\n    obj2[key] = value; // 存放进普通对象，实现转换\n  &#125;\n  return obj2; // 最后进行输出\n&#125;\nconsole.log(result(data2)); // &#123;a.b: 3, c: 10, d[1]: 8&#125;\n\nps:\n这只是简易版，还有很多判断没有加上，写得不好，或者需要补充的地方，请大佬们在评论区指出😊\n","slug":"【前端面试题】——数据转换二","date":"2022-12-26T13:14:11.605Z","categories_index":"js面试题","tags_index":"JavaScript","author_index":"LCS's Blog"},{"id":"33876cf3e210da358d8e4b065eea88e6","title":"axios","content":"浅谈 axios\n什么是 axios？\nAxios 是一个基于 promise 的 异步 ajax 请求库，前端最流行的 ajax 请求库。简单的讲就是可以发送 get、post 请求，负责与后端交互。Vue、React 等框架的出现，促使了 Axios 轻量级库的出现， react/vue 官方都推荐使用 axios 发 ajax 请求。因为 Vue 等，不需要操作 Dom，所以不需要引入 Jquery.js 了\n\naxios 的特点？\n\n可以转换请求数据和响应数据，并对响应回来的内容自动转换成 JSON 类型的数据\n\nAxios 是一个基于 promise 的异步 ajax 请求库，支持 promise 所有的 API\n\n拦截请求和响应（就是前端发送请求前，可以设置自动拦截请求，相当于给请求加条件）\n\naxios.all(promises): 批量发送多个（异步）请求\n\naxios 在览器端/node 端都可以使用\n\n安全性更高，客户端支持防御 XSRF（跨站请求伪造）\n//就是让你的每个请求都带一个从cookie中拿到的key, 根据浏览器同源策略，假冒的网站是拿不到你cookie中得key的，这样，后台就可以轻松辨别出这个请求是否是用户在假冒网站上的误导输入，从而采取正确的策略\n\naxios 常用的两种请求方式\n\naxios({method:’方法’，url: ‘’baseURL: ‘’，data:{name: ‘cc’, sex: ‘man’} })\naxios(&#123;\n  url: \"/login\",\n  method: \"post\",\n  data: &#123;\n    name: \"cc\",\n    sex: \"man\",\n  &#125;,\n&#125;);\naxios.方法名(url, {name:’cc’, sex:’man’})\naxios.get(url[, config])   //get请求 用于列表和信息查询\naxios.delete(url[, config])  //删除\naxios.post(url[, data[, config]])  //post请求用与提交数据，添加信息\naxios.put(url[, data[, config]])  //更新操作\n\n//例如\naxios.post('/login',&#123;name:'cc', sex:'man'&#125;)\n\n说下你了解的 axios 相关配置属性？\n`url`是用于请求的服务器URL ；\n`method`是创建请求时使用的方法,默认是get ；\n`baseURL`将自动加在`url`前面，除非`url`是一个绝对URL。它可以通过设置一个`baseURL`便于为axios实例的方法传递相对URL ；\n`headers`是即将被发送的自定义请求头；\n`params`是即将与请求一起发送的URL参数，必须是一个无格式对象。params:&#123;ID:12345&#125;。\n\naxios 拦截器 【 在请求或响应被 then 或 catch 处理前拦截它们 】\n拦截器分为请求拦截器和响应拦截器：\n请求拦截器（interceptors.requst）是指可以拦截每次或指定 HTTP 请求，并可修改配置项\n响应拦截器（interceptors.response）可以在每次 HTTP 请求后拦截住每次或指定 HTTP 请求，并可修改返回结果项\n\n先创建实例：import axios from &quot;axios&quot;;\n\n&#x2F;&#x2F; todo 创建实例\nconst instance &#x3D; axios.create(&#123;\n  baseURL: &quot;http:&#x2F;&#x2F;www.pudge.wang:3080&#x2F;api&quot;,\n  timeout: 10000, &#x2F;&#x2F; 超时时间\n  headers: &#123; &quot;content-type&quot;: &quot;application&#x2F;json&quot; &#125;, &#x2F;&#x2F; 表单提交 form-data\n  &#x2F;&#x2F; params: &#123;\n  &#x2F;&#x2F;   &#x2F;&#x2F; 只有get请求会来加params\n  &#x2F;&#x2F;   &#x2F;&#x2F; ID: 12345,\n  &#x2F;&#x2F;   token: localStorage.getItem(&quot;token&quot;),\n  &#x2F;&#x2F; &#125;,\n&#125;);\n\n添加请求拦截器:\n// todo 添加请求拦截器\ninstance.interceptors.request.use(\n  function (config) &#123;\n    // console.log(config);\n    // 在发送请求之前做些什么\n    // config.params.token = localStorage.getItem(\"token\");\n\n    // 对一些特殊的接口做一些特殊的处理\n    // 一个项目很多的请求，绝大部分请求都是数据的请求，请求头application/json\n    // 偶尔有个别接口要做表单提交\n\n    // if (config.url === \"/upload\") &#123;\n    //   config.headers = &#123; \"content-type\": \"form-data\" &#125;;\n    // &#125;\n    return config;\n  &#125;,\n  function (error) &#123;\n    // 对请求错误做些什么\n    return Promise.reject(error);\n  &#125;\n);\n\n\n添加响应拦截器:\n// todo 添加响应拦截器\ninstance.interceptors.response.use(\n  function (response) &#123;\n    // 在刚刚得到数据的时候触发\n    // 对响应数据做点什么\n    // console.log(response);\n\n    // 404是没法判断\n    if (response.status === 200) &#123;\n      return response.data;\n    &#125; else if (response.status === 500) &#123;\n      alert(\"服务端错误\");\n    &#125;\n  &#125;,\n  function (error) &#123;\n    // 对响应错误做点什么\n    return Promise.reject(error);\n  &#125;\n);\n\naxios 简单封装\n创建 http.js：import axios from \"axios\";\n// todo 创建实例\nconst instance = axios.create(&#123;\n  baseURL: \"http://www.pudge.wang:3080/api\",\n  timeout: 10000, // 超时时间\n  headers: &#123; \"content-type\": \"application/json\" &#125;, // 表单提交 form-data\n&#125;);\nconst http = &#123;\n  get(url, params) &#123;\n    return instance\n      .get(url, &#123; params &#125;)\n      .then((res) => &#123;\n        // console.log(res);\n        return res;\n      &#125;)\n      .catch((err) => &#123;\n        alert(err.message);\n      &#125;);\n  &#125;,\n&#125;;\nexport default http;\n\n\n","slug":"浅谈 axios","date":"2022-12-26T13:14:11.605Z","categories_index":"数据请求","tags_index":"网络请求","author_index":"LCS's Blog"},{"id":"e838993256c291f049ef0caab62402ab","title":"简单的数据转换","content":"【前端面试题】——数据转换初始数据：const data = [\n       &#123; id: \"1\", name: \"小才\", type: \"fruit\" &#125;,\n       &#123; id: \"2\", name: \"小俞\", type: \"animal\" &#125;,\n       &#123; id: \"3\", name: \"小草\", type: \"fruit\" &#125;,\n       &#123; id: \"4\", name: \"小马\", type: \"fruit\" &#125;,\n       &#123; id: \"5\", name: \"小王\", type: \"animal\" &#125;,\n       &#123; id: \"6\", name: \"小丽\", type: \"haha\" &#125;,\n     ];\n\n转换成：\nconst data = [\n  fruit:[&#123;id:'1',name:'小才'&#125;，&#123;id:'3',name: \"小俞\"&#125;,&#123;id:'4',name: '小马'&#125;],\n  animal:[&#123;id:'2',name:'小俞'&#125;，&#123;id:'5',name: \"小王\"&#125;],\n  haha:[&#123;id:'6',name:'小丽'&#125;],\n]\n\n代码：\n// 创建数据转换成函数\nfunction alterData(data) &#123;\n  // 首先声明两个变量，当容器\n  let res = [];\n  let obj = &#123;&#125;;\n  // 在确保data数据是数组类型的情况下，在此我先不判断了,需要可以isArray判断下\n  // 开始第一层解析，用数组的ruduce方法\n  obj = data.reduce((object, item) => &#123;\n    object[item.type] = res; // 让object的key都是data里每个item的type值\n    return object; // 记得输出 object 对象\n  &#125;, &#123;&#125;);\n  console.log(obj); // 打印下， &#123; fruit:[],animal:[], haha:[] &#125;  初始容器搭建好了，只要存值就好了\n  // 利用 for in 遍历 obj对象,通过filter方法筛选出原始数据data中type值与obj的key相等的对象，存入res数组中\n  for (let key in obj) &#123;\n    res = data\n      .filter((item) => &#123;\n        return item.type === key;\n      &#125;)\n      .map((item) => &#123;\n        // 遍历好就已经完成了归类，再用map方法遍历数组，用delete删除对象里的type属性\n        delete item.type;\n        return item;\n      &#125;);\n    obj[key] = res; // 大功告成\n  &#125;\n  return obj; // 输出最后的结果\n&#125;\nconsole.log(alterData(data)); // 打印结果\n\nps:\n这只是简易版，还有很多判断没有加上，写得不好，或者需要补充的地方，请大佬们在评论区指出😊\n","slug":"【前端面试题】——数据转换","date":"2022-12-26T13:14:11.605Z","categories_index":"js面试题","tags_index":"JavaScript","author_index":"LCS's Blog"},{"id":"bff22f3fd584462e1917ba54fb01e458","title":"用Promise实现简单的红绿灯效果","content":"用 Promise 实现一个简单的红绿灯效果\nJS 部分：\n// js部分\nconst delay = &#123;\n  query: Promise.resolve(), //初始化一个状态为成功的Promise对象\n  wait(timer) &#123;\n    // this.query.then()返回值是一个状态为成功的Promise对象,重新赋值给query\n    this.query = this.query.then((resolve, reject) => &#123;\n      return new Promise((resolve, reject) => &#123;\n        setTimeout(() => resolve(), timer); //到达特定时间返回成功的结果\n      &#125;);\n    &#125;);\n    return this; // 将delay作为返回值\n  &#125;,\n  task(callback) &#123;\n    this.query = this.query.then(() => callback());\n    return this;\n  &#125;,\n&#125;;\n\n//---------------------红绿灯效果------------------\n\nlet box = document.querySelector(\"#box\");\n[...box.children].forEach((el) => Object.assign(el, delay));\nObject.assign(box, delay); //box也是对象,可以使用assign合并delay对象,使其有delay方法\nsetInterval(() => &#123;\n  box\n    .task(() => &#123;\n      box.children[0].style = `background-color:red`;\n    &#125;)\n    .wait(2000)\n    .task(() => &#123;\n      box.children[0].style = `background-color:black`;\n      box.children[1].style = `background-color:green`;\n    &#125;)\n    .wait(2000)\n    .task(() => &#123;\n      box.children[1].style = `background-color:black`;\n      box.children[2].style = `background-color:yellow`;\n    &#125;)\n    .wait(2000)\n    .task(() => &#123;\n      box.children[2].style = `background-color:black`;\n    &#125;);\n&#125;, 0);\n\nhtml 部分：\n&lt;style>\n     #box &#123;\n       display: flex;\n       justify-content: space-around;\n       width: 800px;\n       height: 300px;\n       background-color: rgb(20, 19, 19);\n       align-items: center;\n       border-radius: 40px;\n     &#125;\n     #box > div &#123;\n       width: 200px;\n       height: 200px;\n       border: 1px solid;\n       border-radius: 50%;\n     &#125;\n   &lt;/style>\n &lt;/head>\n &lt;body>\n   &lt;div id=\"box\">\n     &lt;div>&lt;/div>\n     &lt;div>&lt;/div>\n     &lt;div>&lt;/div>\n   &lt;/div>\n  &lt;/body>\n\n\n\n效果：\n","slug":"用Promise实现一个简单的红绿灯效果","date":"2022-12-26T13:14:11.605Z","categories_index":"js面试题","tags_index":"JavaScript","author_index":"LCS's Blog"},{"id":"3324d7472bb09e978be8ffc008c4f887","title":"关于vue2","content":"MVVM 的理解\nMVVM` 表示的是 `Model-View-ViewModel\n1：MVVM 是Model-View-ViewModel 的缩写，它是一种基于前端开发的架构模式。\n\n2：其核心是提供对View 和 ViewModel 的双向数据绑定，这使得ViewModel 的状态改变可以自动传递给 View，即所谓的数据双向绑定。\n\n3：以Vue.js 为例。Vue是一个提供了 MVVM 风格的双向数据绑定的 Javascript 库，专注于View 层。\n\n4：它的核心是 MVVM 中的 VM，也就是 ViewModel。 ViewModel负责连接 View 和 Model，保证视图和数据的一致性，这种轻量级的架构让前端开发\n更加高效、便捷。\n\nModel：模型层，负责处理业务逻辑以及和服务器进行交互。View：视图层，负责将数据模型转化为 UI 显示出来，可以简单的理解为 HTML 页面。ViewModel：试图模型层，用来连接 Model 和 View ，是 Model 和 View 之间的桥梁。每当 V 层获取或者保存数据的时候，都要由 VM 层做中间的处理，从而交给 M 层。\n\n总结MVVM 模式简化了界面和业务的依赖，解决了数据频繁更新。MVVM 在使用当中，利用了双向绑定技术，使得 Model 在变化时，ViewModel 会自动更新，而 ViewModel 变化时，View 也会自动变化。\n\nvue 的优缺点\nvue2 优点：1**.轻量级框架（渐进式框架）**：只关注视图层，是一个构建数据的视图集合，大小只有几十 kb\n2**.简单易学（尤雨溪）**：国人开发，中文文档，不存在语言障碍，易于理解和学习\n3.双向数据绑定：双向是指 ViewModel 中的 data 部分和 View 之间的双向关系。\n​ 正向：数据驱动页面 反向：页面更新数据\n​ 绑定是指自动化处理，data 改变了 view 随之改变，反之也是。\n\nv-for 为什么要加 key给属性一个唯一值，找到相同的元素，直接进行复用 （使用 key 属性可以让 diff 算法更高效，提高渲染效率）\nvue 中使用 v-for 时为什么不能用 index 作为 key\n//当以数组为下标的index作为key值时，其中一个元素(例如增删改查)发生了变化就有可能导致所有的元素的key值发生改变diff算法时比较同级之间的不同，以key来进行关联，当对数组进行下标的变换时，比如删除第一条数据，那么以后所有的index都会发生改变，那么key自然也跟着全部发生改变，所以index作为key值是不稳定的，而这种不稳定性有可能导致性能的浪费，导致diff无法关联起上一次一样的数据。因此，能不使用index作为key就不使用index。\n\n\nv-if 和 v-show 的区别v-for比v-if有更高的优先级，所以两个不能一起使用（vue3 解决了这个问题)\n// v-show，无论初始条件是什么元素都会渲染，它是基于简单地css渲染（给元素添加display：none）\n\n// v-if，是真正的条件渲染，在切换过程中条件块内事件监听和子组件适当地被销毁和重建\n\n总结：\n'  一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好\n\n\nvue 常用修饰符（事件、按键、v-model）事件修饰符\n.stop 阻止事件继续传播.prevent 阻止标签默认行为.capture 使用事件捕获模式,即元素自身触发的事件先在此处处理，然后才交由内部元素进行处理.self 只当在 event.target 是当前元素自身时触发处理函数.once 事件将只会触发一次.passive 告诉浏览器你不想阻止事件的默认行为\n&lt;a v-on:click.stop=\"doThis\">&lt;/a>\n\nv-model 修饰符\n\n.lazy - 将 oninput 事件 切换成 onchange 事件\n.number - 输入字符串转为有效的数字\n.trim - 输入首尾空格过\n\n&lt;input v-model.trim=\"msg\">\n\n键盘事件的修饰符\nenter 回车键.tab 制表键.esc 返回键.space 空格键.up 向上键.down 向下键.left 向左建.right 向右键\n&lt;input @keyup.enter=\"submit\">\n\n修饰键：(也叫系统修饰符)\n.ctrl.alt.shift.meta （就是 ctrl 旁边的 window 图标键\n\n&lt;!-- 按下Ctrl + enter时触发 -->\n&lt;input @keydown.ctrl.13=\"submit\">\n\nv-bind 修饰符\n.sync .sync修饰符，它只是作为一个编译时的语法糖存在。它会被扩展为一个自动更新父组件属性的 v-on 监听器\n&lt;comp :foo.sync=\"bar\">&lt;/comp>\n扩展成\n&lt;comp :foo=\"bar\" @update:foo=\"val => bar = val\">&lt;/comp>\n\nkeep-alive 的作用是什么？原理是什么Vue 的内置组件，当它包裹动态组件时，会缓存不活动的组件实例\n作用： 在组件切换过程中将状态保留在内存中，防止重复渲染 DOM，减少加载时间及性能消耗，提高用户体验性。\n// 1. 将缓存 name 为 test 的组件(基本）\n&lt;keep-alive include='test'>\n  &lt;router-view/>\n&lt;/keep-alive>\n// 2. 将缓存 name 为 a 或者 b 的组件，结合动态组件使用\n&lt;keep-alive include='a,b'>\n  &lt;router-view/>\n&lt;/keep-alive>\n// 3. 使用正则表达式，需使用 v-bind\n&lt;keep-alive :include='/a|b/'>\n  &lt;router-view/>\n&lt;/keep-alive>\n// 4.动态判断\n&lt;keep-alive :include='includedComponents'>\n  &lt;router-view/>\n&lt;/keep-alive>\n// 5. 将不缓存 name 为 test 的组件\n&lt;keep-alive exclude='test'>\n  &lt;router-view/>\n&lt;/keep-alive>\n\n生命周期函数\n\nactivated:在组件被激活时调用，在组件第一次渲染时也会被调用，之后每次 keep-alive 激活时被调用。\ndeactivated：在组件被停用时调用。\n\n注意： 只有组件被 keep-alive 包裹时，这两个生命周期才会被调用，如果作为正常组件使用\n应用场景\n如果未使用 keep-alive 组件，则在页面回退时仍然会重新渲染页面，触发 created 钩子，使用体验不好。\n在以下场景中使用 keep-alive 组件会显著提高用户体验，菜单存在多级关系（如：主页 -&gt; 列表页 -&gt; 详情页）的场景：\n//1.当从主页跳转列表页时，列表页组件重新渲染；\n//2.当从详情页返回列表页时，列表页组件缓存 不重新请求数据\n\n我们还可以通过路由中的 meta 属性来控制，是否需要缓存\n将 test 路由中的 meta 添加 keepAlive 属性为 true，表示当前路由组件要进行缓存。\n&#123;\n  path: '/home',\n  name: 'home',\n  component: () => import('../views/home.vue')\n&#125;,\n&#123;\n  path: '/test',\n  name: 'test',\n  meta:&#123;\n    keepAlive:true\n  &#125;,\n  component: () => import('../views/test.vue')\n\nkeep-alive 代码可以结合 v-if 进行包裹，如果 meta 中的 keepAlive 为 true 进行缓存，否侧不进行缓存。\n&lt;keep-alive>\n  &lt;router-view v-if=\"$route.meta.keepAlive\" />//缓存显示\n&lt;/keep-alive>\n&lt;router-view v-if=\"!$route.meta.keepAlive\" /> //不缓存显示\n\n实际开发中，我们可以结合路由守卫来实现需要缓存组件的缓存。\nexport default &#123;\n  beforeRouteLeave(to, from, next) &#123;\n    to.meta.keepAlive = true;\n    next();\n  &#125;,\n&#125;;\n\n\n虚拟 DOM 的理解\n可以那么说：\n比方说有一段 html 代码，不是直接渲染，而是将 html 代码转成一个 js 的对象，这个对象存在浏览器内存中。当我们要去修改这个 html 的时候，不是不是修改，而是修改那个 js 对象，等待所有的修改都结束了，再一次性地转回成 html，渲染出来。\n什么是 diff 算法？\n// 同级比较：目的是较少的比较次数，减低时间复杂度\n// key的比较：目的找到相同的元素，直接进行复用\n\n\nvue 中组件的传值方式\n父传子:\n\n在父组件的子组件标签上面添加自定义属性；在子组件里面添加 props 选项用于接受自定义属性\n\n使用插槽 接收\n&lt;template #abc>\n    &lt;span>名字&lt;span>\n&lt;/template>\n&lt;template #default>\n    &lt;span>具名插槽 --默认（default）&lt;span>\n&lt;/template>\n接收\n&lt;slot name=\"abc\">&lt;/slot>\n&lt;slot>&lt;/slot>\n使用 this.$root访问根实例，使用this.$parent 访问父组件实例\n\n依赖注入（vue2 没有响应式）\n// provide提供者，依赖\n       // 向所有的子孙组件传递一个msg属性\n       provide() &#123;\n         return &#123;\n           msg: \"hello\",\n           a: this.a,\n         &#125;;\n       &#125;,\n// inject注入\n       inject: [\"msg\", \"a\"],\n\n子传父:\n\n在父组件的子组件标签上面添加自定义事件；在子组件里面调用 this.$emit(“事件名称”, “值”)去传递\n\n使用 this.refs.xxx 来访问子组件实例\n\n作用域插槽\n&lt;template #default&#x3D;&quot;&#123; abc &#125;&quot;&gt;\n  &#x2F;&#x2F; 只能单取\n  &lt;span&gt;&#123;&#123; abc &#125;&#125;&lt;&#x2F;span&gt;\n&lt;&#x2F;template&gt;\n\n&lt;template slot-scope&#x3D;&quot;scope&quot;&gt;\n  &#x2F;&#x2F; scope 代表该作用域范围所有参数\n  &lt;div&gt;&#123;&#123; scope.tit &#125;&#125;&lt;&#x2F;div&gt;\n  &lt;div&gt;&#123;&#123; scope.msg &#125;&#125;&lt;&#x2F;div&gt;\n  &lt;div&gt;&#123;&#123; scope.names &#125;&#125;&lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&#x2F;&#x2F; 子组件 data() &#123; return &#123; count: 10, name:&#39;ahha&#39; &#125;; &#125;,\n&lt;slot :abc&#x3D;&quot;count&quot;&gt;&lt;&#x2F;slot&gt;\n&lt;slot :names&#x3D;&quot;name&quot;&gt;&lt;&#x2F;slot&gt;\n\n兄弟传值:\n通过中央通信 let bus = new Vue()\nA：methods :{ 函数{bus.$emit(‘自定义事件名’，数据)} 发送\nB：created （）{bus.$on(‘A 发送过来的自定义事件名’，函数)} 进行数据接收\n通过中间件\n传值：this.parent.$emit(“事件名”，”值”)或者this.root.$emit((“事件名”，”值”**)**，\n接收：this.parent.$on(“事件名”，（“值”)=&gt;{}）或者this.root.$on(“事件名”，（“值”)=&gt;{})\n\nvue 组件中的 data 为什么是个函数//  对象为引用类型，当复用组件时，由于数据对象都指向同一个data对象，当在一个组件中修改data时，其他重用的组件中的data会同时被修改；而使用返回对象的函数，由于每次返回的都是一个新对象（Object的实例），引用地址不同，则不会出现这个问题。\n\n\ncomputed 和 watch 的区别\ncomputed(计算属性)：\n\n有缓存，他是被动的，只有当它依赖的响应数据改变，才会改变\n\n计算属性可以同时依赖多个值\n\n根据 data 里的值加工计算出新的返回值\ncomputed:&#123;\n                getMoney()&#123;\n                    return '$'+this.money+\"!\"\n                &#125;,\n                reverseStr()&#123;   //缓存\n                    return this.str.split('').reverse().join(\"\")+Math.random()\n                &#125;\n            &#125;\n   data里的值变化了，会重新计算，值不变，会缓存\n计算属性默认是只读的，也可以修改（通过 get 和 set 修改）\n\n\nwatch(监听属性)：\n\n没有缓存，他是主动的，自己发生了改变，从而执行其他的事情\n\n侦听属性只能侦听一个值\n\n监听的函数接收两个参数，第一个是最新的值；第二个是输入之前的值\n\n可以写成handler形式 【高级用法】\n\n有两个属性：\nimmediate：组件加载立即触发回调函数执行\ndeep: deep 的意思就是深入观察，监听器会一层层的往下遍历，给对象的所有属性都加上这个监听器，但是这样性能开销就会非常大了，任何修改obj里面任何一个属性都会触发这个监听器里的 handler\n一般监听对象和数组 （对复杂类型进行深度监听\n\n\n\nexport default &#123;\n\tdata() &#123;\n\t\treturn &#123;\n\t\t\tname: '123',\n             from:&#123; name:'333'&#125;\n\t\t&#125;;\n\t&#125;,\n\twatch: &#123;\n\t\tname(newVal, oldVal) &#123;\n\t\t\tconsole.log('newVal', newVal);// 1234\n\t\t\tconsole.log('oldVal', oldVal);// 123\n\t\t&#125;,\n        form: &#123;\n\t\t\thandler(newVal, oldVal) &#123;\n\t\t\t\tconsole.log('newVal', newVal);\n\t\t\t\tconsole.log('oldVal', oldVal);\n\t\t\t&#125;,\n\t\t\tdeep: true  //深度监听，复杂类型，以监听到对象内部属性的改变\n             immediate: true // 组件加载立即触发回调函数执行,false就是值变化才发生\n\t\t&#125;\n\n\t&#125;\n&#125;\n\nimmediate 监听的时候是否可以获取 dom 元素不能（测试出来结果是 undefined），可以在$nextTick 里面获取，或者在 mounted 获取\n// 当数据改变（改变数据时同步） 视图刷新（更新dom，异步 中间要通知观察者，调用render生成虚拟dom，比较两个虚拟dom用diff算法，在更新）\n// 所有 我们无法 立即获取，数据改变后生成最新的dom\n// vue 提供了一个watcher(观察每一次的dom更新，更新完成后，回调触发，在回调中获取最新的dom)\nthis.$nextTick(()=>&#123;\n  &lt;!-- 在这里获取最新的dom -->\n&#125;)\n\nVue.nextTick(()=>&#123;\n  &lt;!-- 在这里获取最新的dom -->\n&#125;)\n\nWatch 和 computed 的区别computed 支持缓存，只有依赖数据发生改变,才会重新进行计算;而 watch 不支持缓存，数据变,直接会触发相应的操作\ncomputed 不支持异步，当 computed 内有异步操作时无效，无法监听数据的变化，而 watch 支持异步\ncomputed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于 data 中声明过或者父组件传递的 props 中的数据通过计算得到的值;而 watch 监听的函数接收两个参数，第一个参数是最新的值，第二个参数是输入之前的值\n如果一个属性是由其它属性计算而来的，这个属性依赖其它属性，多对一或者一对一，一般用 computed；而当一个属性发生变化时，需要执行对应的操作，一对多，一般用 watch。\n\n$nextTick 的使用\n异步更新队列\n将里面的内容放到下一次事件轮询里面执行\n等待页面渲染完再执行\nvue并不是数据改变后dom立即更新，而是等所有数据修改之后才会更新，所以$nextTick可以在页面渲染完成之后再执行\n\n经典运用场景： better-scroll 滚动插件，请求到数据后高度撑开后页面未渲染而失效\n在使用某个第三方插件时 ，希望在 vue 生成的某些 dom 动态发生变化时重新应用该插件，也会用到该方法，这时候就需要在 $nextTick 的回调函数中执行重新应用插件的方法\nexport default &#123;\n  name: 'HelloWorld',\n  data () &#123;\n    return &#123;\n      testMsg:\"原始值\",\n    &#125;\n  &#125;,\n  methods:&#123;\n    changeTxt:function()&#123;\n      let that=this;\n      that.testMsg=\"修改后的文本值\";  //修改dom结构\n\n      that.$nextTick(function()&#123;  //使用vue.$nextTick()方法可以dom数据更新后延迟执行\n        let domTxt=document.getElementById('h').innerText;\n        console.log(domTxt);  //输出可以看到vue数据修改后并没有DOM没有立即更新，\n        if(domTxt===\"原始值\")&#123;\n          console.log(\"文本data被修改后dom内容没立即更新\");\n        &#125;else &#123;\n          console.log(\"文本data被修改后dom内容被马上更新了\");\n        &#125;\n      &#125;);\n  &#125;\n\n\nvue 中 bus 的使用弊端 【事件总线】优点： 传递数据较为方便，可以进行兄弟之间，父子之间的传递缺点： 必须先 on监听才能进行 emit 触发,$on 事件是不会自动销毁的。需要我们手动来销毁。\n创建 Bus.js 文件\n//抛出Bus 供传输数据的组件引用  代码-->>\nimport Vue from \"vue\";\nconst bus = new Vue();\nexport default bus;\n\n引用组件谁用谁引用\nimport Bus from \"../common/bus.js\";\n//触发，“changeCurrentMsg”为触发的信号名\nBus.$emit(\"changeCurrentPage\", 1);\n\n接受信息\nimport Bus from '../common/bus.js';\n//创建时就要监听，也可以在created中监听\nmounted()&#123;\n\tBus.$on(\"changeCurrentPage\",(val)=>&#123;\n\t                this.currentPage=val;\n\t       &#125;);\n&#125;\n\n//记得销毁，不然会叠加调用监听\n beforDestroy（）&#123;\n         this.$bus.$off(\"vaPage\");  //当这个组件销毁的时候bus也跟着一起销毁\n&#125;\n\n\n使用 vue-bus 公共组件\n1、安装：npm install vue-bus\n2、在main.js中引入vue-bus\nimport Vue from &#39;vue&#39;;\nimport VueBus from &#39;vue-bus&#39;;\nVue.use(VueBus);\n\n在组件中使用\n//触发事件\nthis.$bus.emit(\"changeCurrentPage\",1)；\n//接受事件\nmounted()&#123;\n\tthis.$bus.on(\"changeCurrentPage\",(val)=>&#123;\n\t           this.currentPage=val;\n\t    &#125;);\n&#125;\n//组件销毁接触事件绑定\ndestroyed:function()&#123;\n　　this.$bus.off(\"changeCurrentPage\")\n&#125;\n\n\nvue 的生命周期的理解和各个钩子的实际使用场景\nVue2.0\nbeforeCreated\n// 在实例初始化之后,进行数据侦听和事件/侦听器的配置之前同步调用。  不能访问数据\ncreated\n// 在实例创建完成后被立即同步调用  可以访问数据，但是拿不到真实的dom节点\nbeforeMount\n// 在挂载开始之前被调用\nmounted\n// 实例被挂载后调用  既可以拿到数据也可以拿到节点  可以拿到真的dom节点可以进行dom操作\n通过ref拿到节点\n&lt;p ref=\"parogram\">&lt;/p>\nthis.$refs.parogram 拿到节点\nbeforeUpdate\n// 在数据发生改变后，DOM 被更新之前被调用\nupdated\n// 在数据更改导致的虚拟 DOM 重新渲染和更新完毕之后被调用\nbeforeDestroy\n// 实例销毁之前调用。在这一步，实例仍然完全可用。 清理资源，防止内存泄露\ndestroyed\n// 实例销毁后调用\n缓存阶段\nactivated.\n// 被 keep-alive 缓存的组件激活时调用。\ndeactivated.\n// 被 keep-alive 缓存的组件失活时调用。\n\n\n\n\n创建前/后\n在beforeCreate阶段，vue 实例的挂载元素 el 和数据对象 data 都为 undefined（拿不到 data，不能做数据请求），还未初始化。在created阶段，vue 实例的数据对象 data 有了（能拿到 data，可以做数据请求），el 为 undefined，还未初始化\n\n\n\n载入前/后\n在beforeMount阶段，vue 实例的$el 和 data 都初始化了，但还是挂载之前为虚拟的 dom 节点，data.message 还未替换（可以做数据请求）。在mounted阶段，vue 实例挂载完成，data.message 成功渲染（可以做数据请求，获取 dom 节点）\n\n\n更新前/后\n当 data 变化时，会触发 beforeUpdate 和 updated 方法（数据改变后触发，数据得用，不能在 updataed 修改数据，会造成死循环）\n\n\n销毁前/后\n在执行 destroy 方法后，对 data 的改变不会再触发周期函数，说明此时 vue 实例已经解除了事件监听以及和 dom 的绑定，但是 dom 结构依然存在（beforeDestroy——关闭定时器、事件监听、第三方插件、websocket, destroyed 不做事情）\n\n\n错误处理阶段\nerrorCaptured ， 用于捕获子组件的错误，然后显示回退 UI[就是一个界面，错误处理钩子函数是写在 父组件中，触发条件： 子组件出问题了\n\n\n使用场景created\n可以访问获取数据\n修改数据不会触发 beforeUpdate,updated钩子函数\n可以正常向后端发起请求获取数据\n\nmounted\n可以访问获取数据\n修改数据会触发 beforeUpdate,updated钩子函数\nthis.$refs找到 ref 表示的节点\n可以正常向后端发起请求获取数据\n\nupdated:生命周期 - 更新阶段\n    1. 触发条件： 数据改变【 数据得用 】 &lt;br>\n    2. 触发次数： 多次 &lt;hr>\n    3. updated:  可以做真实DOM操作，可以发送数据请求 &lt;hr>\n\n特别注意:不要在 update beforeUpdate 修改数据，否则会引起死循环\n相关面试题：初始化阶段，我们哪里拿到了虚拟 DOM 呢？created之后，beforeMount前\n\n初始化阶段，我们哪里拿到了真实 DOM 呢？mounted\n\n如果有两个组件，是父子组件，父子组件的初始化阶段是如何执行顺序3.1 父组件： beforeCreate created  beforeMount\n3.2 子组件： beforeCreate created  beforeMount  mounted\n3.3 父组件： mounted\n\n更新阶段真实 DOM 哪里可以拿到？updated\n\n父组件更新阶段触发了，子组件是否会重新渲染父子组件是否有通信[恰好就是通信的数据改了]，\n  有的话应该会的\n  没有的话就不会了\n\n子组件更新阶段触发了，父组件是否会重新渲染父子组件是否有通信[恰好就是通信的数据改了]，，\n  有的话应该会的\n  没有的话就不会了\n\n\nvue 中从 created 和 mouthed 中发送请求的区别是什么created\n// created在模板渲染成html前调用，此时的data已经准备完毕，el仍然是underfined，因此没有渲染成html，所以不能操作dom节点，它主要用来初始化一些数据；\n\n// 即使created中的方法没有执行完，mounted也会被调用\n\nmounted\n// mounted在模板渲染成真实的html之后调用的，此时data，el都已经准备好了，可以操作html的dom节点，可以通过id之类的查找元素，也可以加载一些组件等。\n\n// 挂载到阶段上的初始化方法通常用mounted去操作，主动调起的用methods里面封装方法\n\n\n$router 和 $route 区别\n$ router 路由操作对象 ，只写对象\n$ route 是用来获取路由信息的,只读对象\n$router 是 VueRouter 的一个实例\n他包含了所有的路由，包括路由的跳转方法，钩子函数等，也包含一些子对象（例如 history）\n常用的跳转连接的方法： **this.$router.push( ) ** this.$router.replace( ) tihs.$router.go( )\nthi.$router.push( )\nthis.$router.push(\"/login\");\n//使用对象的形式 不带参数\nthis.$router.push(&#123; path:\"/login\" &#125;);\n//使用对象的形式，参数为地址栏上的参数\nthis.$router.push(&#123; path:\"/login\",query:&#123;username:\"jack\"&#125; &#125;);\n使用对象的形式 ，参数为params 不会显示在地址栏\nthis.$router.push(&#123; name:'user' , params: &#123;id:123&#125; &#125;);\n\nthis.$router.replace( )\npush方法会向 history 栈添加一个新的记录，而replace方法是替换当前的页面，\n不会向 history 栈添加一个新的记录\n\n一般使用replace来做404页面\nthis.$router.replace(’/’)\n\ntihs.$router.go( )\n// 页面路由跳转 前进或者后退\nthis.$router.go(-1); // 后退\nthis.$router.go(1); // 前进\n\n$ route是用来获取路由信息的\n\n1、$route.path\n// 字符串，对应当前路由的路径，总是解析为绝对路径，如 “/foo/bar”。\n\n2、$route.params\n// 一个 key/value 对象，包含了 动态片段 和 全匹配片段，\n// 如果没有路由参数，就是一个空对象。\n\n3.$route.query\n一个 key/value 对象，表示 URL 查询参数。\n// 例如，对于路径 /foo?user=1，则有 $route.query.user == 1，\n// 如果没有查询参数，则是个空对象。\n\n4.$route.hash\n当前路由的 hash 值 (不带 #) ，如果没有 hash 值，则为空字符串。锚点\n\n5.$route.fullPath\n// 完成解析后的 URL，包含查询参数和 hash 的完整路径。\n\n6.$route.matched\n// 数组，包含当前匹配的路径中所包含的所有片段所对应的配置参数对象。\n\n7.$route.name 当前路径名字\n8.$route.meta 路由元信息\n\n\n路由传参的方式有几种？区别是什么\n一、在路由表配置动态路由 “：id（名字）” 设置props 为 true 在组件那边用props 接收\n​ 或者 使用this.$route.params.id取值\n&#123;\n   path: '/login/:id/:name', // 这里用动态路由的方式\n   name: 'login',\n   props:true,\n   component: Login\n&#125;\n\n二、在路由表设置**命名路由 name:”abc” ,**params 传参 [ 不会显示在地址栏 ]\n三、使用 path 来配置路由，通过 query 来传递参数，参数会在 url 后边的?id=?中显示\nquery 和 params的区别总结：\n\nparams 传参，必须使用命名路由的方式传参；\nparams 传参，不会显示在地址栏上，会保存在内存中，刷新会丢失，可以配合本地存储进行使用;\nquery 的参数会显示在地址栏上，刷新不会丢失；\n\n//使用对象的形式，参数为地址栏上的参数\nthis.$router.push(&#123; path:\"/login\",query:&#123;username:\"jack\"&#125; &#125;);\n// 使用对象的形式 ，参数为params 不会显示在地址栏\nthis.$router.push(&#123; name:'user' , params: &#123;id:123&#125; &#125;);\n\n//  router-link 标签传参\n&lt;router-link :to=\"&#123; name: 'login', query: &#123; name:'zs',age: '19' &#125;&#125;\" />\n&lt;router-link :to=\"&#123; path: '/login', parmas: &#123; name:'zs', age: '19' &#125;&#125;\" />\n\n\nvue 的导航守卫有哪些\n全局前置守卫 router.beforeEach 主要用来路由鉴权\nto:即将要进入的路由对象；\nfrom:当前路由正要离开的路由对象；\nnext:一定要调用该方法来解析这个钩子，否则在导航跳转时没有任何效果。执行效果依赖 next 方法的调用参数；\nnext()：进行管道的下一个钩子；\nnext(false)：中断当前的导航；\nnext(’/’) 或者 next({ path: ‘/’ })：跳转到一个不同的地址，在导航到一个界面时，如果不满足跳转条件，使用该方法跳转到另一个界面，代码示例如下\nrouter.beforeEach((to, from, next) => &#123;\n  // to: Route: 即将要进入的目标路由对象\n  // from: Route: 当前导航正要离开的路由\n  // next: Function: 一定要调用该方法来resolve这个钩子。执行效果依赖next方法的调用参数\n&#125;);\n\n\n全局后置守卫 —— router.afterEach()\n可以使用 router.afterEach() 注册一个全局后置守卫，和其他守卫(包括组单个路由独享的守卫以及组件中的守卫)不同的是，全局后置守卫不会接受 next() 函数，也不会改变导航本身；\nrouter.beforeEach((to, from) => &#123;\n  // to: Route: 即将要进入的目标路由对象\n  // from: Route: 当前导航正要离开的路由\n&#125;);\n\n路由独享的守卫 beforeEnter与全局的 beforeEach 完全相同，如果都设置则在 beforeEach 之后紧随执行，参数 to、from、next\nconst router = new VueRouter(&#123;\n  routes: [\n    &#123;\n      path: \"/foo\",\n      component: Foo,\n      beforeEnter: (to, from, next) => &#123;\n        //\n      &#125;,\n    &#125;,\n  ],\n&#125;);\n\n组件内的守卫beforeRouteEnterbeforeRouteUpdate(2.2 新增)beforeRouteLeave\n\nbeforeRouteEnter (to, from, next) &#123;\n   // 在渲染该组件的对应路由被 confirm 前调用\n   // 不！能！获取组件实例 `this`\n   // 因为当守卫执行前，组件实例还没被创建\n   // next（）里面可以写成回调函数，提供vm（相当于this）参数 来访问组件的属性\n    next((vm) => &#123;vm.detailInfo = res.result;&#125;);\n &#125;,\n beforeRouteUpdate (to, from, next) &#123;\n   // 在当前路由改变，但是该组件被复用时调用\n   // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，\n   // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。\n   // 可以访问组件实例 `this`\n &#125;,\n beforeRouteLeave (to, from, next) &#123;\n   // 导航离开该组件的对应路由时调用\n   // 可以访问组件实例 `this`\n\n\nvue 路由模式，hash 模式 和 history 模式区别\n原理：\nhash —— 即地址栏 URL 中的 // # 符号（此 hash 不是密码学里的散列运算）。比如这个 URL：http://www.abc.com/#/hello，hash 的值为 #/hello。\n它的特点在于：hash 虽然出现在 URL 中，但不会被包括在 HTTP 请求中，对后端完全没有影响，因此改变 hash 不会重新加载页面。\n\n// history ——  利用了 HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法。\n（需要特定浏览器支持）这两个方法应用于浏览器的历史记录栈，在当前已有的 back、forward、go 的基础之上，它们提供了对历史记录进行修改的功能。只是当它们执行修改时，虽然改变了当前的 URL，但浏览器不会立即向后端发送请求。\n\n// 因此可以说，hash 模式和 history 模式都属于浏览器自身的特性，Vue-Router 只是利用了这两个特性（通过调用浏览器提供的接口）来实现前端路由.\n\n\n\n\n\nhash\nhistory\n\n\n\nurl 显示\n有#，很 Low\n无#，好看\n\n\n回车刷新\n可以加载到 hash 值对应页面\n一般就是 404 掉了\n\n\n支持版本\n支持低版本浏览器和 IE 浏览器\nHTML5 新推出的 API\n\n\nhistory.replaceState(&#123;&#125;, null, '/b') // 替换路由\nhistory.pushState(&#123;&#125;, null, '/a') // 路由压栈 替换当前地址 被替换地址进入访问历史\nhistory.back() // 返回\nhistory.forward() // 前进\nhistory.go(-2) // 后退2次\n\nhash模式优缺点:\n优点\n只需要前端配置路由表, 不需要后端的参与\n兼容性好, 浏览器都能支持\nhash值改变不会向后端发送请求, 完全属于前端路由\n缺点\nhash值前面需要加#, 不符合url规范,也不美观\n\nhistory 模式的优缺点：\n优点：\n符合url地址规范, 不需要#, 使用起来比较美观\n缺点：\n兼容性不如 hash，且需要服务端支持重定向，否则一刷新页面就404了\n兼容性比较差, 利用了 HTML5 History对象中新增的 pushState() 和 replaceState() 方法,需要特定浏览器的支持.\n\n\n\nvue 的路由懒加载是什么\n文件中包含了所有的用户组件的 js 以及 css 代码，但用户可能根本不会浏览器到某些页面，也就是说根本不需要渲染某些组件，所以 vue-router 提供了一种路由懒加载机制，就是当某个路由规则匹配时，才会去加载下载并加载某个组件，此时可以提升首页的渲染速度.\n路由懒加载实现的基础是组件引入方式的变化，需要使用 如下方式引入组件才可以\n&#123;\n  path:'/',\n  redirect: '/home',\n&#125;,\n&#123;\n  path: '/home',\n  name: 'home',\n  component: () => import('../page/home/HomeView.vue'),\n &#125;\n\n\nvue 中怎么动态劫持属性\n在 vue2.0 中使用 Object.defineProperty( ) 来实现 vue 数据劫持这一行为.\n数据劫持:指的是在访问或者修改对象的某个属性时，通过一段代码拦截这个行为，进行额外的操作或者修改返回结果\nlet vm = &#123;\n  name: \"张三\",\n&#125;;\nlet vm = Object.defineProperty(vm, \"name\", &#123;\n  get() &#123;\n    console.log(\"get...\");\n    return \"张三\";\n  &#125;,\n  set(newValue) &#123;\n    console.log(\"set...\");\n    console.log(\"新值\", newValue);\n  &#125;,\n&#125;);\n// 多个属性 遍历数组\nObject.keys(vm).forEach((key) => &#123;\n  let value = vm[key];\n  Object.defineProperty(vm, key, &#123;\n    get() &#123;\n      console.log(\"get....\");\n      return value;\n    &#125;,\n    set(newV) &#123;\n      console.log(\"set....\");\n      if (newV !== value) &#123;\n        value = newV;\n      &#125;\n    &#125;,\n  &#125;);\n&#125;);\n\n修改对象总结：\nObject.defineProperty() 可以监测到属性的获取、修改，但是新增、删除监测不到\n\n修改数组总结：\n//若执行的方法修改了原数组， Object.defineProperty() 监测不到数组的变化，但是若该方法不\n修改原数组;\n//返回一个新数组的时候， Object.defineProperty()就可以检测到数组的变化。\n\nProxy：在 Vue3.0 中将会通过 Proxy 来替换原本的 Object.defineProperty() 来实现数据响应式。Proxy 是 ES6 中新增的功能，它可以用来自定义对象中的操作。可以说 Proxy 是 defineProperty 的升级版。\nvar newVm = new Proxy(vm, &#123;\n  get(target, key) &#123;\n    console.log(\"get.....\");\n    console.log(target);\n    return target[key];\n  &#125;,\n  set(target, key, newV) &#123;\n    console.log(\"set.....\");\n    if (target[key] !== newV) &#123;\n      target[key] = newV;\n    &#125;\n  &#125;,\n&#125;);\n\n总结：\nproxy 不需要对数组、对象进行比遍历，性能上比较好，而且可以完美的监听到任何方式的数据改变，唯一的缺陷就是浏览器的兼容性不好。\n\nVue2 的数据响应式缺陷\n修改对象：Vue 无法检测 property 的添加或移除。由于 Vue 会在初始化实例时对 property 执行 getter/setter 转化，所以 property 必须在 data 对象上存在才能让 Vue 将它转换为响应式的。\n可以使用 Vue.set(object, propertyName, value) 方法向嵌套对象添加响应式 property\nVue.set(要修改的对象, 要修改的值, 修改值);\nthis.$set(this.someObject, \"b\", 2);\n\n修改数组：【\n1、vue 对于数组项是简单数据类型的情况没有劫持,这也导致了 vue 数组使用的一个问题，当数组项是简单数据类型时，修改数据项时视图并不会更新。\n2、通过索引修改简单数据类型没有响应式\nVue.set(要修改的数组, 要修改的值, 修改值)\nthis.$set((this.数组, 要修改的值, 修改值)\n\n\n因为es5的object.defineProperty无法监听对象属性的删除和添加\n不能监听数组的变化，除了push&#x2F;pop&#x2F;shift&#x2F;unshift&#x2F;splice&#x2F;spObject.definert&#x2F;reverse，其他都不行\nObject.defineProperty只能遍历对象属性直接修改(需要深拷贝进行修改)\n\n\nvue2 的双向数据绑定的原理是什么\nvue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty()来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。\n\nvue3.0 怎么实现的双向数据绑定何为双向数据流，单向数据流呢？单向数据流\n顾名思义，数据流是单向的。数据流动方向可以跟踪，流动单一，追查问题的时候可以更快捷。缺点就是写起来不太方便。要使 UI 发生变更就必须创建各种 action 来维护对应的 state\n\n双向数据绑定\n数据之间是相通的，将数据变更的操作隐藏在框架内部。优点是在表单交互较多的场景下，会简化大量与业务无关的代码。缺点就是无法追踪局部状态的变化，增加了出错时 debug 的难度。\n\nproxy 和 object.definepropoty 的区别（1）Object.defineProperty 监听的是对象的每个属性，而 Proxy 监听的是对象本身。\n（2）使用 Object.defineProperty 需要遍历对象的每个属性，而 Proxy 则直接代理对象，不需要遍历操作。\n（3）Proxy 对新增属性也可以监听，Object.defineProperty 不可。\n（4）Proxy 可以监听到数组的变化。\nproxy 为什么可以劫持到动态绑定的属性\nmixin 混入的使用情况\n什么是 Mixin 混入\n混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。\n\n场景运用：\n有两个非常相似的组件，他们的基本功能是一样的，但他们之间又存在着足够的差异性。他们可能会公用一部分业务逻辑，但是他们的页面结构又不相同。这个时候就可以使用mixin来让代码复用。（类似于JS库，暴露出来的方法达到函数复用的效果。又区别于JS库，它继承了vue中script所有对象，包括生命周期，data，methods）\n\n\nvue 项目的性能优化1、v-if 和 v-show 区分使用场景\n2.computed 和 watch 区分使用场景\n3.v-for 遍历必须为 item 添加 key，且避免同时使用 v-if\n4.事件及销毁\n5.长列表以及不需要数据劫持的场景\n\n\nvuex 的使用流程\nvuex 官方解释：Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式 + 库。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。\n\n什么时候使用它？\nVuex 可以帮助我们管理共享状态，并附带了更多的概念和框架。这需要对短期和长期效益进行权衡。\n\n如果您不打算开发大型单页应用，使用 Vuex 可能是繁琐冗余的。确实是如此——如果您的应用够简单，您最好不要使用 Vuex。一个简单的 store 模式就足够您所需了。但是，如果您需要构建一个中大型单页应用，您很可能会考虑如何更好地在组件外部管理状态，Vuex 将会成为自然而然的选择。\n\n一、创建 store 仓库\nimport &#123; createStore &#125; from \"vuex\";\n// ts声明接口\nexport interface CountState &#123;\n  n: number;\n&#125;\n\nexport default createStore(&#123;\n  // 最好用模块，好管理\n  modules: &#123;\n    count: &#123;\n      namespaced: true, // 开启命名空间\n      state: &#123;\n        n: 1,\n      &#125;,\n      actions: &#123;\n        add(&#123; commit &#125;, &#123; payload &#125;) &#123;\n          //todo &#123; commit &#125;是store解构出来   &#123;payload&#125; 时传过来的参数，需要结构\n          const action = &#123;\n            type: \"addcount\",\n            payload,\n          &#125;;\n          commit(action);\n        &#125;,\n      &#125;,\n      mutations: &#123;\n        addcount(state, action) &#123;\n          console.log(action); //todo  &#123;type: 'count/add', payload: '23'&#125;\n          state.n += Number(action.payload);\n          // state.n++\n        &#125;,\n      &#125;,\n    &#125;,\n  &#125;,\n&#125;);\n\nmain.js 配置\nimport store from \"./store\";\ncreateApp(App).use(router).use(store).use(Antd).mount(\"#app\");\n\n组件内使用：\nvue2.o 用法：辅助函数： mapState 获取值 mapMutations 获取同步方法 mapActions 调用异步方法\nimport &#123; mapState, mapActions, mapMutations &#125; from \"vuex\"\n\ncomputed: &#123;\n    ...mapState(\"count\", &#123;\n      n: (state: any) => &#123;\n        return state.n;\n      &#125;,\n    &#125;),\n  &#125;,\n  methods: &#123;\n    ...mapMutations(\"count\", [\"addcount\"]),  // ...展开预算符\n    ...mapActions(\"count\", [\"add\"]),\n  &#125;,\n\nvue3.o 用法 使用 useStore hooks\nimport &#123; useStore &#125; from \"vuex\";\nsetup()&#123;\n    const store = useStore();\n   //todo computed 获取仓库值  不要忘记加上仓库名\n    const n = computed(() => store.state.count.n);\n   //todo 调用 store的 mutations 方法  store.commit(&#123;type:'仓库名/方法名'&#125;)\n     const addcount = () => &#123;\n      store.commit(&#123;\n        type: \"count/addcount\",\n      &#125;);\n    &#125;;\n    //todo 调用 store的 mutations 方法  store.dispath(&#123; type:'仓库名/方法名',payload:要传的参数 &#125;)\n    const add = () => &#123;\n      store.dispatch(&#123;\n        type: \"count/add\",\n        payload: num.value,\n      &#125;);\n    &#125;;\n&#125;\n\n数据渲染: 在挂载结束阶段调用仓库的 Actions 异步方法请求数据 - 在 commit mutations 改变数据\n\n组件化和模块化的区别\n模块化：给同一个功能业务的代码起一个模块名,然后负责对应的部分\n模块化是从代码逻辑角度划分，把一些可复用的代码，抽离为单个模块，以便于项目的维护和开发保证职能化的单一。 比如登录模块，他的功能就是登录，注册功能又是一个模块\n\n组件化：将可以复用的代码封成组件\n组件化是从UI界面角度划分的，从页面上每看到一个独立的区域，都可以看作一个组件。前端组件化开发是便于组件的复用，把一些可复用的UI元素，抽离出来不断复用便于减少代码的书写\n\n\n\nwebpack 的作用是什么// webpack是一种前端资源构建工具，一个静态模块打包器\n// 由于浏览器解析不了es6及以上的语法，无法编译less/sacc等，所以我们需要各种插件去es6编译es5、将less编译成css，比较杂乱，所以就有了webpack将这些插件组合在一起\n\nwebpack 的打包流程是什么1.初始化一个管理包\nyarn init\n\n2 、安装使用 webpack 所需要的依赖包\nyarn add webpack webpack-cli -D\n\n3、 在 package.json 文件中配置 scripts(自定义命令)\nscripts: &#123;\n    \"build\": \"webpack\"\n&#125;\n\n4、将新建的打包文件引入 webpack 的默认打包入口 src/index.js 中\n5、在根目录下执行 yarn build 命令打包\n\naxios 是怎么封装的\n封装的好处：\n// 1. 统一数据请求的处理\n// 2. 考虑底层库将来可能会切换\n// 3. 数据请求可能设计到一些业务逻辑\n\n整体思维：\n1. timeout  + baseURL\n2. 拦截器\n3. request函数的封装\n    1. 对参数的类型，对返回值的类型做约定\n    2. 通过method不同，做对应的switch操作\n\n创建 index 文件 【cookie 封装】用到了 cookie：\nfunction setCookie(name: string, value: string | number, n: number): void &#123;\n  var oDate = new Date();\n  oDate.setDate(oDate.getDate() + n);\n  document.cookie = name + \"=\" + value + \";expires=\" + oDate;\n&#125;\n\nfunction getCookie(name: string): string | undefined &#123;\n  var str = document.cookie;\n  var arr = str.split(\"; \");\n  for (var i = 0; i &lt; arr.length; i++) &#123;\n    //console.log(arr[i]);\n    var newArr = arr[i].split(\"=\");\n    if (newArr[0] == name) &#123;\n      return newArr[1];\n    &#125;\n  &#125;\n&#125;\n\nfunction removeCookie(name: string): void &#123;\n  setCookie(name, 1, -1);\n&#125;\n\nfunction People(name: string) &#123;\n  this.name = name;\n&#125;\n\nexport &#123; getCookie, setCookie, removeCookie, People &#125;;\n\n创建请求 request 文件：\n\nimport axios, &#123; AxiosInstance, AxiosRequestConfig, AxiosResponse &#125; from 'axios';\nimport qs from 'qs'; // 主要用于post请求，把请求参数转从 json换成 form date数据\nimport * as cookie from './index';\n\n//todo 创建自定义请求实例\nconst ins: AxiosInstance = axios.create(&#123;\n    timeout: 20000,\n    baseURL: 'http://59.110.226.77:5000/api/private/v1/'\n&#125;)\n\n//todo 拦截器 发送请求时做操作\nins.interceptors.request.use((config: AxiosRequestConfig): AxiosRequestConfig => &#123;\n    //todo 携带token\n    const token: string | undefined = cookie.getCookie('token')\n    config.headers.common['Authorization'] = token; // 请求头配置token.方便后端验证\n    return config;\n&#125;, (error: any): Promise&lt;any> => &#123;\n    return Promise.reject(error)\n&#125;)\n//todo 拦截器  接收到请求时做操作\nins.interceptors.response.use((res: AxiosResponse&lt;any>): AxiosResponse&lt;any> => &#123;\n    return res.data;\n&#125;, (error: any): Promise&lt;any> => &#123;\n    return Promise.reject(error)\n&#125;)\n\ninterface IConfig &#123;\n    url: string;\n    method?: string;\n    data?: &#123;\n        [key: string]: any;\n    &#125;,\n    postType?: string;\n&#125;\nconst request = (&#123;\n    url,\n    method = 'GET', //请求方法\n    data,\n    postType = 'form'  // formData请求方式\n&#125;: IConfig): Promise&lt;AxiosResponse&lt;any>> => &#123;\n    // 根据请求的类型来进行划分\n    switch (method.toLocaleLowerCase()) &#123;\n        case 'post': // 一般作于增加\n             // formData请求方式\n            if (postType === 'file') &#123;\n                const p: FormData = new FormData(); //文件\n                for (let key in data) &#123; // 将data的所有参数全部给了p\n                    p.append(key, data[key])\n                &#125;\n                return ins.post(url, p)\n            &#125;\n             // 普通post请求方式\n            return ins.post(url, qs.stringify(data))\n        case 'put': // 一般作于修改\n            return ins.put(url, data)\n        case 'delete': // 删除\n            return ins.delete(url, &#123; data &#125;)\n        case 'patch':  // 更新数据\n            return ins.patch(url, data);\n        default: // get 查询\n            return ins.get(url,&#123;params: data&#125;)\n    &#125;\n&#125;\nget：获取数据\npost：提交数据（表单提交+文件上传）\nput：更新数据（所有数据推送到后端）\npatch：更新数据（只将更改的数据推送到后端）\ndelete：删除数据\n\nexport default request\n\n\nvue 怎么做反向代理跨域 vue.config.js 配置跨域\n主要流程：\n前端跨域 --- 反向代理 &lt;hr>\n   1. 首先反向代理要写在  vue.config.js  文件中  &lt;br>\n   2. 报什么错就是跨域问题  &lt;hr>\n   3. 易犯错地方 &lt;br>\n     3.1 代理标识 会起 &lt;br>\n     3.2 改了配置文件要重启项目  &lt;br>\n     3.3 请求的url要去掉域名和协议 &lt;br>\n   &lt;button @click=\"send\"> 发送数据请求 &lt;/button>\n\n创建 vue.config.js 文件： 【项目配置文件改了，必须重启项目】\n 项目配置文件改了，必须重启项目\nmodule.exports = &#123;\n  lintOnSave: false,\n  devServer: &#123;\n    //todo proxy就是反省代理配置\n    // https://m.maoyan.com/ajax/movieOnInfoList?token=&amp;optimus_uuid=70CFC3A08B7911EB8E337BEC41DC7263F6E47DC364A54B0891A2A3D261F1FCD0&amp;optimus_risk_level=71&amp;optimus_code=10\n    proxy: &#123;\n      // 代理路径【域名后的第一个路径】: 代理配置\n      '/ajax': &#123;\n        // 目标源\n        target: 'https://m.maoyan.com',\n        changeOrigin: true,//使用我们当前的服务器源来代替目标源\n      &#125;\n    &#125;\n  &#125;\n&#125;;\n\n\n如何在相应拦截器中处理 token//todo 拦截器 发送请求时做操作\nins.interceptors.request.use(\n  (config: AxiosRequestConfig): AxiosRequestConfig => &#123;\n    //todo 携带token\n    const token: string | undefined = cookie.getCookie(\"token\"); //获取token\n    config.headers.common[\"Authorization\"] = token; // 请求头配置token.方便后端验证\n    return config;\n  &#125;,\n  (error: any): Promise&lt;any> => &#123;\n    return Promise.reject(error);\n  &#125;\n);\n//todo 拦截器  接收到请求时做操作\nins.interceptors.response.use(\n  (res: AxiosResponse&lt;any>): AxiosResponse&lt;any> => &#123;\n    return res.data;\n  &#125;,\n  (error: any): Promise&lt;any> => &#123;\n    return Promise.reject(error);\n  &#125;\n);\n\n项目：图片地址变成变量注意点;：require需要 import 引入 或者 require（图片路径）\n\namfe-flexible(可伸缩布局方案) postcss-pxtorem 进行移动端适配1.介绍amfe-flexible\n// amfe-flexible是配置可伸缩布局方案，主要是将1rem设为viewWidth/10。\n2.介绍postcss-pxtorem\n// postcss-pxtorem是postcss的插件，用于将像素（px）单元生成rem单位。\n\n具体步骤：1. 安装两个插件\nnpm install amfe-flexible --save\nnpm install postcss-pxtorem --save\n\n2. 在 main.js 导入 amfe-flexible\nimport &#39;amfe-flexible&#39;\n\n在安装 postcss-pxtorem 的时候会生成一个文件.postcssrc.js\n\nmodule.exports = &#123;\n          // 按照设计稿750px 的 1/2\n        plugins: [\n         \"postcss-pxtorem\"：&#123;\n             rootValue: 37.5, //根据设计稿宽度除以10进行设置，假设设计稿为375，即rootValue设为37.5\n             propList: ['*'], //设置需要转换的属性，*为所有都进行转换\n              // 该项仅在使用 Circle 组件时需要\n            // 原因参见 https://github.com/youzan/vant/issues/1948\n            selectorBlackList: ['van-circle__layer']\n            &#125;\n         ]\n&#125;\n\n5、在index.html头部加入手机端自适应meta\n在首页中(项目中-public-index.html)中添加以下meta标签\n&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n\n\n\n5、在 index.html 头部加入手机端自适应 meta在首页中(项目中-public-index.html)中添加以下 meta 标签\n&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n\n\nvue-lazyload 图片资源懒加载对于图片过多的页面，为了加速页面加载速度，所以很多时候我们需要将页面内未出现在可视区域内的图片先不做加载， 等到滚动到可视区域后再去加载。这样对于页面加载性能上会有很大的提升，也提高了用户体验。我们在项目中使用 Vue 的 vue-lazyload 插件：\n（1）安装插件\nnpm install vue-lazyload --save-dev\n\n（2）在入口文件 man.js 中引入并使用\nimport VueLazyload from \"vue-lazyload\";\n\n然后再 vue 中直接使用\nVue.use(VueLazyload);\n\n或者添加自定义选项\nVue.use(VueLazyload, &#123;\n  preLoad: 1.3,\n  error: \"dist/error.png\",\n  loading: \"dist/loading.gif\",\n  attempt: 1,\n&#125;);\n\n（3）在 vue 文件中将 img 标签的 src 属性直接改为 v-lazy ，从而将图片显示方式更改为懒加载显示：\n&lt;img v-lazy=\"/static/img/1.png\">\n\n\n第三方插件的按需引入我们在项目中经常会需要引入第三方插件，如果我们直接引入整个插件，会导致项目的体积太大，我们可以借助 babel-plugin-component ，然后可以只引入需要的组件，以达到减小项目体积的目的。以下为项目中引入 element-ui 组件库为例：\n（1）首先，安装 babel-plugin-component ：\nnpm install babel-plugin-component -D\n\n（2）然后，将 .babelrc 修改为：\n\n&#123;\n  \"presets\": [[\"es2015\", &#123; \"modules\": false &#125;]],\n  \"plugins\": [\n    [\n      \"component\",\n      &#123;\n        \"libraryName\": \"element-ui\",\n        \"styleLibraryName\": \"theme-chalk\"\n      &#125;\n    ]\n  ]\n&#125;\n\n\n（3）在 main.js 中引入部分组件：\n\nimport Vue from 'vue';\nimport &#123; Button, Select &#125; from 'element-ui';\n\nVue.use(Button)\nVue.use(Select)\n\n\n二，Webpack 层面的优化\n2.1、Webpack 对图片进行压缩在 vue 项目中除了可以在 webpack.base.conf.js 中 url-loader 中设置 limit 大小来对图片处理，对小于 limit 的图片转化为 base64 格式，其余的不做操作。所以对有些较大的图片资源，在请求资源的时候，加载会很慢，我们可以用 image-webpack-loader 来压缩图片：\n（1）首先，安装 image-webpack-loader ：\nnpm install image-webpack-loader --save-dev\n\n（2）然后，在 webpack.base.conf.js 中进行配置：\n&#123;\n  test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/,\n  use:[\n    &#123;\n    loader: 'url-loader',\n    options: &#123;\n      limit: 10000,\n      name: utils.assetsPath('img/[name].[hash:7].[ext]')\n      &#125;\n    &#125;,\n    &#123;\n      loader: 'image-webpack-loader',\n      options: &#123;\n        bypassOnDebug: true,\n      &#125;\n    &#125;\n  ]\n&#125;\n\n用 element-ui 最新版 2.15.9 引入 form 表单 里面的 el-date-picker 【日期选择器】组件会报错：\nAvoid mutating a prop directly since the value will be overwritten whenever the parent component re-renders.\nInstead, use a data or computed property based on the prop's value. Prop being mutated: \"value\"\n从报错内容上来看，我们改动了子组件中引用的父组件的变量，也就是 props 中的数据，是不能这么操作的；\n因为Vue的单项数据流，子组件不能改动父组件props传过来的值\n\n解决：\n锁定组件，发现是 el-date-picker 组件抛出的警告。通过在 github 上搜索，最终找到了答案\n\n问题出在了这个 PR 21806 增加了 props placement 用来适应位置，但是之前的代码 created 时有给 placement 赋值。\n\nthis.placement = PLACEMENT_MAP[this.align] || PLACEMENT_MAP.left;\n\n说白了之前 placement 是 data 的对象，现在变成 props 了，然后修改就报错了\n\n降级\n先卸载最新版\n将最新版2.15.9 降级到 2.15.8\n\n优化总结：\n//代码包优化\n\n屏蔽sourcemap，vue.config.js里面设置productionSourceMap为false\n\n对项目代码中的js,css,svg,ico文件进行gzip压缩，在vue-cli脚手架的配置信息中，有对代码进行压缩的配置项，例如index.js的通用配置，productionGzip设置为true，但是首先需要对compress-webpack-plugin支持\n\n对路由组件进行懒加载，在router.js里面对组件进行按需加载\n\n//2.源码优化\n\nv-if和v-show的选择性调用。对频繁调用的，不需要权限的显示隐藏，可以选择v-show，减少系统开销。\n\n对item设置唯一的key值\n\n细分vuejs组件，尽可能组件化\n\n减少watch的数据，有些情况可用vuex取代\n\n内容类系统的图片资源按需加载\n\n//3.用户体验优化\n\n防抖节流实现（按钮点击，下拉刷新，下拉搜索，上拉加载，页面滚动等情况）\n\n骨架屏加载\n\n//4.cdn资源调用\n\n引入的js,css,image用cdn地址来实现\n\nbetter-scroll 插件做滚动安装 better-scroll\nnpm i &#39;better-scroll&#39;\n\n页面引入：\nimport BScroll from 'better-scroll';\n\n创建实例：\n bs = new BScroll('.scroll-wrapper', &#123;\n                pullUpLoad: &#123;  // 触底\n                threshold: 100,\n                &#125;,\n                scrollX: false,\n                scrollY: true,\n                click: true, // 不阻止点击事件\n               //  bounce: true, //回弹动画\n              &#125;);\nbs.on('pullingUp', () => &#123;\n               console.log(\"触底了\") // 监听下拉是否到底，到底后就执行一次函数，可以获取新的数据\n                 this.moreListAsync().then((res) => &#123;\n                 this.finishMore(res)\n                &#125;)\n             &#125;)\n  bs.refresh();// 重新计算高度\n bs.finishPullUp();//告诉bs已经结束下拉行为，可以重新下拉；\n\n项目可说难点： 【 vue 组件中 click 事件失效 】\n解决：使用了 bette-scroll插件做滚动。发现 better-scroll 的配置中没有设置 click：true，设置过之后 click 事件成功。\n\nVue 中组件的封装\n注册和使用一个组件在 componet 下创建一个 button.vue 的文件，放置 button 组件代码。创建一个组建的 button 组件，，并且指定 name 为 oneButton。\n&lt;template>\n  &lt;button class=\"one-button\">按钮组件&lt;/button>\n&lt;/template>\n\n&lt;script>\nexport default &#123;\n  name: \"oneButton\", //todo 设置名字方便注册\n&#125;;\n&lt;/script>\n&lt;style>\n.one-button &#123;\n  width: 200px;\n  height: 40px;\n  background-color: rgb(70, 130, 241);\n&#125;\n&lt;/style>\n\n创建组件完成后，不能在项目中直接使用，需要到 main.js 中注册才可以使用。\n// 第一步：导入button组件\nimport OneButton from \"./components/button.vue\";\n\n// 第二步：注册组件,设置(组件名，组件)\nVue.component(OneButton.name, OneButton);\n\n注册完成后，组件就可以在项目中使用了。\n&lt;template>\n  &lt;div>\n    &lt;one-button>&lt;/one-button>\n  &lt;/div>\n&lt;/template>\n\n\n封装一个 element-ui 风格的按钮需要使用到的知识：\n\n组件通讯\n组件插槽\nprops 校验\n\n参数支持：\n\n\n\n参数名\n参数描述\n参数类型\n默认值\n\n\n\ntype\n按钮类型（primary/success/warning/danger/info）\nstring\ndefault\n\n\nplain\n是否是朴素按钮\nboolean\nfalse\n\n\nround\n是否是圆角按钮\nboolean\nfalse\n\n\ncircle\n是否是圆形按钮\nboolean\nfalse\n\n\ndisabled\n是否禁用按钮\nboolean\nfalse\n\n\nicon\n图标类名\nstring\n无\n\n\n事件支持：\n\n\n\n事件名\n事件描述\n\n\n\nclick\n点击事件\n\n\n使用插槽：\n为何？ 凡是希望组件中内容可以灵活设置的地方，都需要用到 slot 插槽来自定义内容\n按钮组件：\n&lt;template&gt;\n  &lt;button class&#x3D;&quot;one-button&quot;&gt;\n   &lt;span&gt;&lt;slot&gt;&lt;&#x2F;slot&gt;&lt;&#x2F;span&gt; &#x2F;&#x2F;父组件可以随便定义内容了\n  &lt;&#x2F;button&gt;\n&lt;&#x2F;template&gt;\n\n在使用时就可以直接输入文本，定义按钮文本内容了：\n&lt;template>\n  &lt;div>\n    &lt;one-button>登录&lt;/one-button>\n    &lt;one-button>删除&lt;/one-button>\n    &lt;one-button>取消&lt;/one-button>\n  &lt;/div>\n&lt;/template>\n\n设置 button 组件的 type 属性 【让按钮支持 type 属性，使得按钮支持不同样式：】第一步:父组件组件传递 type 属性\n&lt;template>\n  &lt;div id=\"app\">\n    &lt;div class=\"row\">\n      &lt;one-button>按钮&lt;/one-button>\n      &lt;one-button type=\"primary\">primary按钮&lt;/one-button>\n      &lt;one-button type=\"success\">success按钮&lt;/one-button>\n      &lt;one-button type=\"info\">info按钮&lt;/one-button>\n      &lt;one-button type=\"danger\">danger按钮&lt;/one-button>\n      &lt;one-button type=\"warning\">warning按钮&lt;/one-button>\n    &lt;/div>\n  &lt;/div>\n&lt;/template>\n\n第二步：子组件接收负组件传递的数据\nexport default &#123;\n  name: 'oneButton',\n  // 此时对props进行校验，值接收string类型的type值\n  props: &#123;\n    type:&#123;\n      type: String，\n      // 设置默认值：如果不传值，那么使用default\n      default: 'default'\n    &#125;\n  &#125;,\n  created () &#123;\n    console.log(this.type)//defalut primary success info danger warning\n  &#125;\n&#125;\n\nbutton 组件的 plain 属性 【添加多类名】第三步:通过绑定类名的方法动态控制样式，由于 plain 类型是布尔值，所以在类型中我们使用对象的形式来控制样式\n&lt;template>\n  &lt;button\n    class=\"one-button\"\n    :class=\"[`one-button-$&#123;type&#125;`,&#123;\n    'is-plain':plain\n  &#125;]\"\n  >\n    &lt;span>&lt;slot>&lt;/slot>&lt;/span>\n  &lt;/button>\n&lt;/template>\n\n第四步：设置不同类型的样式，由于 plain 类型是以对象的形式在类中定义的，所以使用获取属性的方法定义样式\n\n// 朴素按钮样式\n.one-button.is-plain&#123;\n  &amp;:hover,\n  &amp;:focus&#123;\n    background: #fff;\n    border-color: #489eff;\n    color: #409eff;\n  &#125;\n&#125;\n.one-button-primary.is-plain&#123;\n  color: #409eff;\n  background: #ecf5ff;\n  &amp;:hover,\n  &amp;:focus&#123;\n    background: #409eff;\n    border-color: #409eff;\n    color: #fff;\n  &#125;\n&#125;\n.one-button-success.is-plain&#123;\n  color: #67c23a;\n  background: #c2e7b0;\n  &amp;:hover,\n  &amp;:focus&#123;\n    background: #67c23a;\n    border-color: #67c23a;\n    color: #fff;\n  &#125;\n&#125;\n\nbutton 组件的 round 属性 button 组件的 circle 属性设置 round 属性和之前的相似，只要在组件中定义好了样式，动态获取属性值即可。\ncircle: &#123; type: Boolean, default: false &#125;\n\nbutton 组件中使用字体图标首先需要有字体图标，我们可以去阿里巴巴矢量图标库下载。\n\n在asset目录下新建一个fonts目录，存放我们下载到的字体图标\n\n在main.js中引入字体图标\nimport &#39;.&#x2F;assets&#x2F;fonts&#x2F;iconfont.css&#39;\n\n将下载的字体图标css文件中的类名做修改，我将icon全部改为了one-icon，并且将初始的iconfont类改为了[class*&#x3D;&#39;one-icon&#39;]，当类名中有one-icon时使用，如下\n\n[class*&#x3D;&#39;one-icon&#39;] &#123;\n  font-family: &quot;iconfont&quot; !important;\n  font-size: 16px;\n  font-style: normal;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n&#125;\n.one-icon-bluetoothoff:before &#123;\n  content: &quot;\\e697&quot;;\n&#125;\n\n父组件传递图标名，子组件接收并且放到图标中\n父组件传值：\n      &lt;one-button icon&#x3D;&quot;bluetoothon&quot;&gt;&lt;&#x2F;one-button&gt;\n      &lt;one-button type&#x3D;&quot;primary&quot; icon&#x3D;&quot;camera&quot;&gt;照相机&lt;&#x2F;one-button&gt;\n      &lt;one-button type&#x3D;&quot;success&quot; icon&#x3D;&quot;course&quot;&gt;&lt;&#x2F;one-button&gt;\n      &lt;one-button type&#x3D;&quot;info&quot; icon&#x3D;&quot;bluetooth_link&quot;&gt;&lt;&#x2F;one-button&gt;\n子组件接收：\n icon: &#123;\n      type: String,\n      default: &#39;&#39;\n    &#125;\n使用接收到的字体图标。在没有传入icon时隐藏&lt;i&gt;标签，在slot插槽没有传入值时，不显示&lt;span&gt;标签\n &lt;button class&#x3D;&quot;one-button&quot; :class&#x3D;&quot;[&#96;one-button-$&#123;type&#125;&#96;,&#123;\n    &#39;is-plain&#39;:plain,\n    &#39;is-round&#39;:round,\n    &#39;is-circle&#39;:circle,\n  &#125;]&quot;&gt;\n  &lt;i v-if&#x3D;&quot;icon&quot; :class&#x3D;&quot;&#96;one-icon-$&#123;icon&#125;&#96;&quot;&gt;&lt;&#x2F;i&gt;\n  &lt;!-- 如果没传入文本插槽，则不显示span内容 --&gt;\n   &lt;span v-if&#x3D;&quot;$slots.default&quot;&gt;&lt;slot&gt;&lt;&#x2F;slot&gt;&lt;&#x2F;span&gt;\n  &lt;&#x2F;button&gt;\n\n  设置icon配套样式，使图标和文字之间有一定间隔\n  .one-button [class*&#x3D;one-icon-]+span&#123;\n  margin-left: 5px;\n&#125;\n\n\n\nbutton 组件中的点击事件我们在使用组件时，直接给组件定义事件是不会被触发的。我们需要在组件中定义一个点击事件，这个点击事件不进行其他操作，只出发父组件中的点击事件。\n组件中的定义点击事件：\n&lt;template&gt;\n  &lt;button class&#x3D;&quot;one-button&quot; :class&#x3D;&quot;[&#96;one-button-$&#123;type&#125;&#96;,&#123;\n    &#39;is-plain&#39;:plain,\n    &#39;is-round&#39;:round,\n    &#39;is-circle&#39;:circle,\n  &#125;]&quot;\n  @click&#x3D;&quot;handleClick&quot;\n  &gt;\n  &lt;i v-if&#x3D;&quot;icon&quot; :class&#x3D;&quot;&#96;one-icon-$&#123;icon&#125;&#96;&quot;&gt;&lt;&#x2F;i&gt;\n  &lt;!-- 如果没传入文本插槽，则不显示span内容 --&gt;\n   &lt;span v-if&#x3D;&quot;$slots.default&quot;&gt;&lt;slot&gt;&lt;&#x2F;slot&gt;&lt;&#x2F;span&gt;\n  &lt;&#x2F;button&gt;\n&lt;&#x2F;template&gt;\n\n定义一个点击事件，这个点击事件的作用是调用父组件中的点击事件，并且回调\nmethods: &#123;\n    handleClick (e) &#123;\n      this.$emit('click', e)\n    &#125;\n  &#125;\n\n父组件在使用时定义自己的点击事件，其本质是子组件中的点击事件触发父组件中的点击事件。\n\n&lt;div class=\"row\">\n  &lt;one-button @click=\"getInfo\">按钮&lt;/one-button>\n&lt;/div>\n  methods: &#123;\n    getInfo () &#123;\n      console.log('获取信息！！')//获取信息！！\n    &#125;\n  &#125;\n\n\nbutton 组件中的 disabled 属性和之前相似，只要父子组件传值并且动态获取这个值并且赋给 disabled 属性,并且设置一个 disabled 样式即可。\n父组件\n&lt;div class=\"row\">\n  &lt;one-button @click=\"getInfo\" disabled>按钮&lt;/one-button>\n&lt;/div>\n\n子组件\n&lt;template>\n  &lt;button\n    class=\"one-button\"\n    :class=\"[`one-button-$&#123;type&#125;`,&#123;\n    'is-plain':plain,\n    'is-round':round,\n    'is-circle':circle,\n    'is-disabled':disabled\n  &#125;]\"\n    @click=\"handleClick\"\n    :disabled=\"disabled\"\n  >\n    &lt;i v-if=\"icon\" :class=\"`one-icon-$&#123;icon&#125;`\">&lt;/i>\n    &lt;span v-if=\"$slots.default\">&lt;slot>&lt;/slot>&lt;/span>\n  &lt;/button>\n&lt;/template>\n// props disabled: &#123; type: Boolean, default: false &#125; // css\n.one-button.is-disabled&#123; cursor: no-drop; &#125;\n\naxios拦截器请求拦截器、响应拦截器\n\n请求拦截器 在请求发送前进行必要操作处理，例如添加统一 cookie、请求体加验证、设置请求头等，相当于是对每个接口里相同操作的一个封装；\n响应拦截器 同理，响应拦截器也是如此功能，只是在请求得到响应之后，对响应体的一些处理，通常是数据统一处理等，也常来判断登录失效等。\n\n","slug":"关于vue的学习笔记","date":"2022-12-26T13:14:11.605Z","categories_index":"Vue","tags_index":"vue2","author_index":"LCS's Blog"},{"id":"0b7869d8948a44428f2ef3d011726b80","title":"ES6新增详解","content":"ES6 新增详解let 声明变量和 const 声明常量，两个都有块级作用域ES5中是没有块级作用域的，并且var有变量提升，在let中，使用的变量一定要进行声明\n\n箭头函数ES6中的函数定义不再使用关键字function()，而是利用了()&#x3D;&gt;来进行定义\n\n特点：箭头函数中的this始终指向箭头函数定义时的离this最近的一个函数，如果没有最近的函数就指向window。\n\n模板字符串模板字符串是增强版的字符串，用反引号（&#96;）标识，可以当作普通字符串使用，也可以用来定义多行字符串\n\n解构赋值ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值\n\nfor … of…循环for…of循环可以遍历数组、Set和Map结构、某些类似数组的对象、对象，以及字符串\n应用场景\n&#x2F;&#x2F;arguments是个类数组对象，通常先要将其转换为数组才能遍历，但for...of可以直接遍历\n\nimport、export 导入导出ES6标准中，Js原生支持模块(module)。将JS代码分割成不同功能的小块进行模块化，将不同功能的代码分别写在不同文件中，各模块只需导出公共接口部分，然后通过模块的导入的方式可以在其他地方使用\n\nset 数据结构\n方法：add()、delete()、has()、clear()\n\nSet数据结构，类似数组。所有的数据都是唯一的，没有重复的值。它本身是一个构造函数\n\n应用 【数组去重、并集（Union）、交集（Intersect）和差集（Difference】\nlet arr &#x3D; [3, 5, 2, 2, 5, 5];\nlet unique &#x3D; [...new Set(arr)];\n&#x2F;&#x2F; [3, 5, 2]\n\n2、并集（Union）、交集（Intersect）和差集（Difference）\n\n… 展开运算符可以将数组或对象里面的值展开；还可以将多个值收集为一个变量\n\n应用 【合并数组、浅拷贝数组、类数组转数组、使用 Math 函数判断最大最小】1. 合并数组\n\narr1.push(...arr2) &#x2F;&#x2F; 将arr2 追加到数组的末尾\narr1.unshift(...arr2) &#x2F;&#x2F; 将arr2 追加到数组的开头\n\n2. 拷贝数组\n\nvar arr &#x3D; [1,2,3];\nvar arr2 &#x3D; [...arr]; &#x2F;&#x2F; 和arr.slice()差不多\narr2.push(4)\n&#x2F;&#x2F;记住：数组中的对象依然是引用值，所以不是任何东西都“拷贝”过去了。\n\n3.将arguments或者NodeList转换为Array\n\nvar myFn &#x3D; function(...args) &#123;\n&#x2F;&#x2F; ...\n\n修饰器 @ 【比如 vue 的事件修饰符 代替 v-on:】decorator【待 科 ra 腾】是一个函数，用来修改类甚至于是方法的行为。修饰器本质就是编译时执行的函数\n\nclass 类的继承ES6 中不再像 ES5 一样使用原型链实现继承，而是引入 Class 这个概念 extends【继承】class Person&#123;&#125; 父类\nclass Worker extends Person&#123;\nconstructor(name, age,job) &#123;\n         super(name, age);\n          this.job &#x3D; job;\n    &#125;\n&#125;  子继承父类\n\n\npromisePromise 是 ES6 提出的一种解决异步编程的方案，比传统的解决方案（回调函数和事件）更合理、强大\n它有三种状态，分别是 pending-进行中、fulfilled-已完成、rejected-已失败。\n【 可以链式调用解决回调地狱问题 】\nPromise 的实例方法有 .then()/.catch() /finally() 三种，\n静态方法有 all / race / allSettled [塞抖~] / any / resolve / reject 六种\nPromise.prototype.then()\nPromise.prototype.catch()\nPromise.prototype.finally() // 不管 Promise 对象最后状态如何，都会执行的操作。\nPromise.all()  // 方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。所有参数数组 Promise 实例执行 resolve 回调后，新实例执行 resolve 回调；如果中间有任何一个 Promise 实例执行 reject 回调，那么新实例就直接执行 reject 回调了。\nPromise.race)  //顾名思义，就是竞赛，返回最快完成那一个 Promise 实例。只要参数数组中有一个 Promise 实例执行 resolve 回调或 reject 回调后，新实例就直接返回结果。\nPromise.allSettled( ) // 方法只有等到 参数 数组 的所有 Promise 实例都发生状态变更，返回的 Promise 实例才会发生状态变更，无论是执行 resolve 回调还是 reject 回调的状态。\n'有时候，我们不关心异步操作的结果，只关心这些操作有没有结束。这时，Promise.allSettled()方法就很有用。\nPromise.any()  // 返回任意一个最快执行 resolve 回调的 Promise 实例。\nPromise.resolve()  // 方法返回一个以给定值解析后的 Promise 实例。相当于执行 then 方法里面的 _resolvePromise。\nPromise.reject() // 方法返回一个带有拒绝原因的 Promise 实例。\n\n\n\nSymbol是一种基本类型。Symbol 通过调用 symbol 函数产生，它接收一个可选的名字参数，该函数返回的 symbol 是唯一的\n\nSymbol 的值是唯一的，常用来解决命名冲突问题。\nSymbol 的值不能和其他数据进行运算。\n\n应用场景：\n应用场景1：使用Symbol来作为对象属性名(key)\n\n应用场景2：使用Symbol来替代常量\n\n应用场景3：使用Symbol定义类的私有属性/方法\n\n//正常的 Symbol\nlet h1 = Symbol('小宝')\nlet h2 = Symbol('小宝')\nconsole.log(h1 === h2) // false\n\n//相等的Symbol   ----使用 Symbol.for()\nlet h3 = Symbol.for('小宝')\nlet h4 = Symbol.for('小宝')\nconsole.log(h1 === h2) // true\n\n\nMapMap类型是键值对的有序列表，而键和值都可以是任意类型\n\n属性和方法：size()、set()、get()、has()、delete()、clear()\n\n\n// 声明Map\n        let m = new Map()\n​\n        // 1.添加元素(键值对)\n        m.set('name','小宝')\n        m.set('age',18)\n​\n        // 2.获取元素\n        console.log(m.get(name)) //小宝\n​\n        // 3.删除元素\n        m.delete('name')\n​\n        // 4.获取元素个数\n        let size = m.size\n        console.log(size) //1\n​\n        // 5.检测是否包含某个元素\n        console.log(m.has('age')); //true\n\n        // 6.清空Map\n        m.clear()\n        console.log(m) //0\n\n\n\nProxy 代理使用代理（Proxy）监听对象的操作，然后可以做一些相应事情\n\nES6原生提供了Proxy构造函数，用来生成Proxy实例。\n\nvar proxy = new Proxy(target, handler);\nProxy对象的所有用法，都是上面的这种形式。不同的只是handle参数的写法。其中new Proxy用来生成Proxy实例，target是表示所要拦截的对象，handle是用来定制拦截行为的对象。\n\nvar proxy = new Proxy(&#123;&#125;, &#123;\n  get: function(target, property) &#123;\n    return 35;\n  &#125;\n&#125;);\n\nproxy.time // 35\nproxy.name // 35\nproxy.title // 35\n上面是一个拦截读取属性的行为的例子。要使Proxy起作用，必须针对Proxy实例进行操作，而不是针对目标对象（target）进行操作。\n\n\n\n","slug":"ES６新增详解","date":"2022-12-26T13:14:11.604Z","categories_index":"web前端","tags_index":"ES6笔记","author_index":"LCS's Blog"},{"id":"343c996ed04fbebbae1554517bbe60b6","title":"React小记（二）","content":"React 学习总结( 二 )1、HOC(高阶组件)\nHigher-Order Components 就是一个函数，传给它一个组件，它返回一个新的组件。作用：可以给组件添加相同的结构,添加相同的属性等等,增强组件的功能，以及进行复用\n温馨提示：一般用 with xxx.js 单独放置高阶组件，默认就是高阶组件\nconst hoc = (Comp) => &#123;\n  return class extends Component &#123;\n    render()\n      // todo &#123;...this.props&#125;将这个组件接收到的所有的props，接着往下传\n      return (\n        &lt;>\n          &lt;Comp count=\"3\" &#123;...this.props&#125; />\n        &lt;/>\n      );\n    &#125;\n  &#125;;\n&#125;;\nclass App extends Component &#123;\n  render() &#123;\n    console.log(this.props); // count=3\n    return (\n      &lt;>\n        &lt;h2>高阶组件&lt;/h2>\n      &lt;/>\n    );\n  &#125;\n&#125;\n\n// const App2 = hoc(App);\nexport default hoc(App);\n\n2、Portal\nPortals 提供了一个最好的在父组件包含的 DOM 结构层级外的 DOM 节点渲染组件的方法。ReactDOM.createPortal(child,container);\n\n第一个参数 child 是可渲染的 react 子项，比如元素，字符串或者片段等。第二个参数 container 是一个 DOM 元素。import React, &#123; Component &#125; from &quot;react&quot;;\nimport &#123; createPortal &#125; from &quot;react-dom&quot;;\n\nclass Child extends Component &#123;\n  render() &#123;\n    return createPortal(&lt;div&gt;child组件&lt;&#x2F;div&gt;, document.querySelector(&quot;body&quot;));\n  &#125;\n&#125;\n\n3、组件的生命周期(旧版)\n前提：只有类组件才有生命周期！一、挂载阶段constructor就是 react 的第一个生命周期，constructor 是组件被实例化的时候就调用，只调用一次特点：可以将接收 props，当作初始值，达到修改 props 的效果\n// constructor就是react的第一个生命周期，constructor是组件被实例化的时候就调用，只调用一次\n // 初始化state，改变事件的this，得到ref变量等等以及处理props\n constructor(props) &#123;\n   super(props);\n   this.state = &#123;\n     count: 10+props.属性,\n     list: [1, 2, 3, 4, 5, 6, 7],\n     this.fn = this.fn.bind(this)\n     this.ipt = createRef();\n   &#125;;\n\ncomponentWillMount      将被弃用表示挂载前,已经被废弃了,没啥用，不能做数据请求, 因为 fiber(16 版本)算法的存在，有可能导致请求做多次，影响性能render ：render 也是生命周期，它必须要返回 jsx, 页面显示的内容，可以做解构以及对数据的处理, 不要在 render 做数据请求componentDidMount  用的很多\n表示挂载结束,可以做任意的事情，包括数据请求特点：可以数据请求，设置定时器\ncomponentDidMount() &#123;\n    console.log(\"componentDidMount\");\n    setTimeout(() => &#123;\n      this.setState(&#123;\n        count: 20,\n      &#125;);\n    &#125;, 2000);\n  &#125;\n\n二、更新阶段shouldComponentUpdate 用的较多\n询问是否需要更新， 必须要返回 true 或者 false\n触发时机：父级 props 改变和内部的 state 数据改变\n参数：nextProps、nextState,更新后的 props 和更新后的 state\nshouldComponentUpdate(nextProps, nextState) &#123;\n  console.log(\"shouldComponentUpdate\");\n  console.log(nextState.count);//20 更新后\n  console.log(this.state.count);//10，默认10\n  return false;\n  if (nextState.count === this.state.count) &#123;\n    return false;\n  &#125; else &#123;\n    return true;\n  &#125;\n    return nextState.count !== this.state.count;//优化后\n  &#125;\n\n扩展：PureComponent，有复杂类型不好判断，所以有了它可以让 react 自己控制是否需要更新，值的类型也不限制,推荐直接写上\nimport React, &#123; PureComponent &#125; from &quot;react&quot;;&#x2F;&#x2F;先结构出来\n\nclass Child extends PureComponent &#123; &#x2F;&#x2F;直接用\n  render() &#123;\n    console.log(&quot;child render&quot;);\n    return &lt;div&gt;child组件 - &#123;this.props.count&#125;&lt;&#x2F;div&gt;;\n  &#125;\n\ncomponentWillUpdate 将被弃用\nUNSAFE_componentWillUpdate() &#123;\n   &#x2F;&#x2F; 跟vue不同的是，这里是数据是改变之前的数据\n   &#x2F;&#x2F; console.log(this.state.count);\n   console.log(&quot;componentWillUpdate&quot;);\n &#125;\n\ncomponentDidUpdate  更新后  不要在这里修改数据,会造成死循环\n// componentDidUpdate表示更新后\n// 不要在这里修改数据,会造成死循环\ncomponentDidUpdate() &#123;\n  // this.setState(&#123;\n  //   count: 30\n  // &#125;)\n  console.log(\"componentDidUpdate\");\n&#125;\n\n三、卸载阶段componentWillUnmount 用的较多\n// todo 卸载阶段\n// todo 卸载定时器，卸载websocket，移出事件监听，销毁echarts的实例等第三方插件\ncomponentWillUnmount() &#123;\n  console.log(\"componentWillUnmount\");\n&#125;\n\n父子组件渲染顺序：只要父组件渲染了，子组件默认也必定会渲染\n父 render -&gt; 子 render -&gt; 子 componentDidMount -&gt; 父 componentDidMount\n\n4、组件的生命周期(新版 16.3 之后)\n\n1.getDerivedStateFromProps 必须要加 static,不常用\n触发时机：父级 props 改变和内部的 state 数据改变\n此方法适用于罕见的用例，即 state 的值在任何时候都取决于 props\n// todo getDerivedStateFromProps必须要加static, 需要有state\n  // todo 根据props的值得到一个新的state(可以有一个state，让这个state的值一直保持和某个props一致)\n  // todo 里面必须要返回一个对象或者null\n state = &#123;\n    count: 10,\n    prevCount: 10,\n  &#125;;\n// 父级初始值为20,设置了定时器，2秒后变成40，每次改变都会触发该生命周期\n  static getDerivedStateFromProps(nextProps, nextState) &#123;\n    console.log(\"getDerivedStateFromProps\"）\n    // todo 1. nextProps.num 20, nextState.prevCount 10 -> count 20 prevCount 20\n    // todo 2. nextProps.num 40, nextState.prevCount 20 -> count 40 prevCount 40\n    // todo 3. nextProps.num 40, nextState.prevCount 40 -> null //最后一次state的触发结果\n    if (nextProps.num === nextState.prevCount) &#123;\n      return null;\n    &#125; else &#123;\n      return &#123;\n        count: nextProps.num,\n        prevCount: nextProps.num,\n      &#125;;\n    &#125;\n  &#125;\n// 修改后触发 static getDerivedStateFromProps\ncomponentDidMount() &#123;\n    setTimeout(() => &#123;\n      this.setState(&#123;\n        count: 80,\n      &#125;);\n    &#125;, 4000);\n  &#125;\n\n2.getSnapshotBeforeUpdate 不常用\n描述：在更新之前得到一个快照 注意！必须和 componentDidUpdate 一起使用\n作用：在最近一次渲染输出（提交到 DOM 节点）之前调用。它使得组件能在发生更改之前从 DOM 中捕获一些信息（例如，滚动位置）。此生命周期的任何返回值将作为参数传递给 componentDidUpdate()。\n此用法并不常见，但它可能出现在 UI 处理中，如需要以特殊方式处理滚动位置的聊天线程等。\n应返回 snapshot 的值（或 null）。\n// todo 在更新之前得到一个快照\n// todo 必须和componentDidUpdate一起使用\n// todo 可以得到dom更新前的ui信息\n// todo 此用法并不常见，但它可能出现在 UI 处理中，如需要以特殊方式处理滚动位置的聊天线程等。\ngetSnapshotBeforeUpdate(prevProps, prevState) &#123;\n  console.log(\"getSnapshotBeforeUpdate\");\n  return 123;\n&#125;\n// todo 传递给dom更新以后\ncomponentDidUpdate(prevProps, prevState, snapshot) &#123;\n  console.log(\"componentDidUpdate\", snapshot);\n&#125;\n\n","slug":"React学习总结( 二 )","date":"2022-12-26T13:14:11.604Z","categories_index":"React","tags_index":"React笔记","author_index":"LCS's Blog"},{"id":"e104371ef5567a01c59c8cbd7ed22e5b","title":"React小记【Router V6】","content":"React 学习总结( 五 ) 【 路由 V6 系列】\nreact-router-dom(路由 v6 版本)\n新旧版本区别:一、注册路由的时候 v5 的 Switch 改为了 Routes import &#123;Route, Routes &#125; from 'react-router-dom' //引入react-router\n\n&lt;div>\n        &#123;/* 注册路由（编写路由链接） */&#125;\n    &lt;Routes >\n        ......\n        ......\n    &lt;/Routes>\n\n二、v6 不再支持用 Route 标签包裹子组件，可以直接使用 element 属性 注册组件 【默认是精准匹配，排它性路由】import &#123; Route, Routes &#125; from \"react-router-dom\"; //引入react-router\n\n&lt;div>\n  &#123;/* 注册路由（编写路由链接） */&#125;\n  &lt;Routes>\n    &lt;Route path=\"/about\" element=&#123;&lt;About />&#125; />\n  &lt;/Routes>\n&lt;/div>;\n\n三、v6 中默认是没有路由信息了，需要使用 hooks 去获取&#123;\n  /* useLocation, useParams, useMatch依旧可以用，useHistroy没了 */\n&#125;\n\n四、v6 中，Route 先后顺序不再重要，它能够自动找出最优匹配路径 【404 页面还是放最后】五、在 v6 中移除了 NavLink 中的 activeClassName 的这个属性 【可以使用三元或者逻辑与运算符的方式实现这个功能】&lt;li>\n  &#123;/* activeClassName被删掉了 */&#125;\n  &#123;/* isActive表示是否匹配的true或者false */&#125;\n  &lt;NavLink\n    to=\"/home\"\n    className=&#123;(&#123; isActive &#125;) => &#123;\n      return isActive &amp;&amp; \"select\";\n    &#125;&#125;\n  >\n    home\n  &lt;/NavLink>\n&lt;/li>\n\n六、在 v6 中将 Redirect 改为 Navigate当匹配不到路由时，需要使用 Redirect 做重定向，跳转到我们定义的组件（页面）中\n&lt;Redirect to=\"/home/\" /> ==> // &lt;Route path=\"/\" element =&#123;&lt;Navigate replace to=\"/home\" />&#125; />  不加 replace 默认是 push\n\n七、v6 嵌套路由改为相对匹配，不再像 v5 那样必须提供完整路径 ，新增 Outelt 组件【index 保持和上一级路由相同的路径】&#123;\n  /* 嵌套路由可以在一处渲染, 用Outlet组件渲染，Outlet相当于vue的router-view */\n&#125;\n&#123;\n  /* index保持和上一级路由相同的路径 */\n&#125;\n&lt;Routes>\n  &lt;Route path=\"/home\" element=&#123;&lt;Home />&#125;>&lt;/Route>\n  &lt;Route path=\"/about\" element=&#123;&lt;About />&#125;>\n    &#123;/* &lt;Route path=\"about1\" element=&#123;&lt;About1 />&#125;>&lt;/Route> */&#125;\n    &lt;Route index element=&#123;&lt;About1 />&#125;>&lt;/Route>\n    &lt;Route path=\"about2\" element=&#123;&lt;About2 />&#125;>&lt;/Route>\n  &lt;/Route>\n&lt;/Routes>;\n\nconst About = () => &#123;\n  return (\n    &lt;>\n      &lt;div>about页面&lt;/div>\n      &lt;ul>\n        &lt;li>\n          &lt;Link to=\"/about\">about1&lt;/Link>\n        &lt;/li>\n        &lt;li>\n          &lt;Link to=\"/about/about2\">about2&lt;/Link>\n        &lt;/li>\n      &lt;/ul>\n      &lt;hr />\n      &#123;/* 嵌套路由可以在一处渲染, 用Outlet组件渲染，Outlet相当于vue的router-view */&#125;\n      &lt;Outlet />\n    &lt;/>\n  );\n&#125;;\n\n八、v6 用 useNavigate 实现编程式导航，不再使用 useHistoryimport &#123; Link, Routes, Route, Navigate, useNavigate &#125; from \"react-router-dom\";\n\nconst Home = () => &#123;\n  const navigate = useNavigate();\n\n  const fn = () => &#123;\n    // 相当于push方法\n    navigate(\"/about\");\n    // 相当于replace方法\n    // navigate(\"/about\", &#123; replace: true &#125;);\n\n    // 直接加数字相当于go方法\n    // navigate(2);\n  &#125;;\n   return (\n    &lt;div>\n      home页面 - &lt;button onClick=&#123;fn&#125;>btn&lt;/button>\n    &lt;/div>\n  );\n\n九、v6 目前没有 prompt 组件阻止不期望的导航。如果在 v6 中要实现相应的功能，必须自己想办法，这可能是目前 v5 唯一的优势\n\n","slug":"React学习总结( 五 ) 【 路由V6系列】","date":"2022-12-26T13:14:11.604Z","categories_index":"React","tags_index":"React笔记","author_index":"LCS's Blog"},{"id":"7b3e4977044b53ba020eff72809f2f12","title":"React小记【immutable与hooks】","content":"React 学习总结( 六 ) 【 immutable 与 hooks 】\nimmutable\n一、什么是 immutable？immutable，译为\"不可改变的\"，是一种持久化数据。它有一旦被创建就不会被修改的特性。\n当你修改 immutable 对象的时候返回新的 immutable。但是原数据不会改变。\n\n二、为什么要使用 immutable？//   用处可大了。进行 js 对象的深拷贝对性能的消耗太大时（使用了递归），例如 Redux 中的深拷贝，就需要用到 immutable 来提升性能，从而避免牵一发而动全身。\n//   当你使用 immutable 后再进行深拷贝的时候，只会拷贝你改变的节点，从而达到了节省性能的目的。\n\n总结：immutable 的不可变性让纯函数更强大，每次都返回新的 immutable 的特性让程序员可以对其进行链式操作，用起来更方便\n三、immutable 的简单实用\n初始化安装： npm i immutable -S  // yarn add immutable\n// 使用时解构方法\nimport &#123; Map, List, Seq, fromJS, Range &#125; from \"immutable\";\nMap 数据结构immutable.Map()：创建一个类似于 js 中的对象的Map 对象\nlet map = immutable.Map(&#123;\n  name: \"Apple\",\n  age: 19,\n  sex: \"男\",\n&#125;);\nconsole.log(map); // Map &#123; \"name\":\"Apple\", \"age\":19, \"sex\":\"男\" &#125;\n\n操作 Map：\n\nmap.set 【增加数据】\nlet map1 = map.set(\"sign\", \"呜呜\");\nconsole.log(map1); // Map &#123; \"name\":\"Apple\", \"age\":19, \"sex\":\"男\", \"sign\":\"呜呜\" &#125;\nmap.setIn 【setIn 可以深层操作，第一个参数是个数组，数组中第一个元素是操作的对象的 key 值，第二个元素是 value 值】\nlet map1 = map.setIn([\"obj\", \"xxx\"], \"xxx\"); // 深层的set\nconsole.log(map1); // Map &#123; \"name\":\"Apple\", \"age\":19, \"sex\":\"男\", \"obj\":&#123; \"xxx\":\"xxx\" &#125; &#125;\nmap.delete &amp;&amp; map.deleteIn【删除】\nmap.delete(\"a\"); // 删除 a 的值\nmap.deleteIn([\"a\", \"b\"]); // 删除 a 中 b 的值\n改\nmap.update()\n参数1：需要更新的值\n参数2：回调函数，返回一个更新后的值\n\nmap.updateIn() 深层更新\n参数1：一个数组，第一个元素是父元素，第二个元素为目标子元素\n参数2：回调函数，参数为目标值的值，返回值为一个更新后的值\n\nlet map1 = map.update(\"a\", function (x) &#123;\n  return x + 1;\n&#125;);\nlet map2 = map.updateIn([\"a\", \"b\"], function (x) &#123;\n  return x + 1;\n&#125;);\nmap.get() 【 查取值】 【 返回的不是 immutable 对象了 而是里边定义的正常值 】\nmap.get(\"a\"); // &#123;a:1&#125; 得到1。\nmap.getIn([\"a\", \"b\"]); // &#123;a:&#123;b:2&#125;&#125; 得到2。\n\n\nList 数据结构：immutable.List()：创建一个类似于 js 中的数组的List 对象\n  &#x2F;&#x2F; 创建immutable数组\n  const list1 &#x3D; List([1, 2]); &#x2F;&#x2F; 创建\n  const list2 &#x3D; list1.push(3, 4, 5);  &#x2F;&#x2F; 增加\n  const list3 &#x3D; list2.unshift(0); &#x2F;&#x2F;向前增加\n  const list4 &#x3D; list1.concat(list2, list3); &#x2F;&#x2F; 合并\n  console.log(list1.size &#x3D;&#x3D;&#x3D; 2);\n  console.log(list2.size &#x3D;&#x3D;&#x3D; 5);\n  console.log(list3.size &#x3D;&#x3D;&#x3D; 6);\n  console.log(list4.size &#x3D;&#x3D;&#x3D; 13);\n&#x2F;&#x2F; 删\nlist.splice(1,1)\n&#x2F;&#x2F; 改\nlist.splice(1,1,10)\n&#x2F;&#x2F; 查\nlist.getIn([0])\nAPI**merge()**：合并 map 对象\nlet newMap &#x3D; map.merge(map1)\n\n**toObject()**：immutable 的 map 对象转 JS 对象\n浅转换，只转换最外层\n\n**toArray()**：immutable 的 list 对象转 JS 数组\n浅转换，只转换最外层\n\n**toJS()**：immutable 的 map 对象/list 对象 转 JS 对象/JS 数组\n深转换，全部转换，更耗费性能\n\n**Map()**：JS 对象或数组转换成 immutable\n浅转换，只转换最外层\n\n**fromJS()**：JS 对象/JS 数组 转换成 immutable\n深转换，全部转换，更耗费性能。\n\nSeq():既可以生成 immutable 对象，也可以生成 immutable 数组,是有惰性的(可以从结果出发)\nconst oddSquares = Seq([1, 2, 3, 4, 5, 6, 7, 8])\n  .filter((x) => &#123;\n    console.log(\"filter x:\" + x);\n    return x % 2 !== 0;\n  &#125;)\n  .map((x) => &#123;\n    console.log(\"map x:\" + x);\n    return x * x;\n  &#125;);\nconsole.log(oddSquares.get(1));\n9;\n\nconst aRange = Range(1, Infinity) // 滑块\n    .skip(1000) // 略过\n    .map((n) => -n)\n    .filter((n) => n % 2 === 0)\n    .take(2)\n    .reduce((r, n) => r * n, 1);\n  console.log(aRange);\n\n  return (\n    &lt;>\n      &lt;h2>immutable&lt;/h2>\n      &lt;input type=\"range\" />\n    &lt;/>\n  );\n&#125;;\n\nhooks 【重点】\nuseState 【让函数组件可以定义自己的 state】// todo hooks只能给函数组件用\n// todo hooks可以在不增加组件树层级的情况下增加组件功能\n// todo hooks可以增加代码可读性，将功能代码聚合，方便阅读维护\n// todo hooks只能在函数组件的顶层调用\n\n// todo useState是让函数组件可以定义自己的state\n// todo useState调用会返回一个数组, 分别是变量和改变变量的方法\n// todo useState需要接收一个参数，是变量的初始值\n// todo useState改变数据是异步的\n\nuseEffect [ 噎 faiKs ]【用于处理副作用，代替生命周期】// todo useEffect没有返回值，里面需要传入一个函数作为参数\n// todo 如果useEffect里面只传入了一个函数，相当于类组件的componentDidMount和componentDidUpdate\n// todo useEffect还可以接收第二个参数，是一个数组（依赖数组）\n// todo 如果第二个参数是空数组，相当于类组件的componentDidMount\n// todo 如果第二个参数有内容，相当于vue的watch\n// todo 如果第一个函数参数里面返回一个函数，相当于类组件的componentWillUnmount\n\nuseLayoutEffect 【跟 useEffect 类似， 同步执行副作用】import React, &#123; useState, useLayoutEffect &#125; from \"react\";\n// todo useLayoutEffect跟useEffect类似的，会在componentDidMount和componentDidUpdate之后同步调用,会阻塞代码执行, 优先于useEffect执行\n// todo 只有当加载完毕以后需要改变dom样式的时候用，可以避免页面抖动\n// todo 绝大部分情况下，推荐使用useEffect\n\nmemo 【高阶组件，给函数组件用的，作用和 PureComponent 完全相同】import React, &#123; memo &#125; from \"react\";\n\nconst Child = memo(() => &#123;\n  console.log(\"child render\");\n  return &lt;div>child组件&lt;/div>;\n&#125;);\n\nuseCallback 【用于缓存函数】 【一般用在自定义事件】&#x2F;&#x2F; todo 第一个参数是需要被缓存的函数，第二个参数是一个依赖数组\n\n&#x2F;&#x2F; todo 当有函数要作为自定义事件的时候，这个函数就需要加useCallback\n\n\nuseMemo 【当作 vue 的计算属性去理解，缓存的是函数的返回值】const oddArr = useMemo(() => &#123;\n  return arr.filter((item) => item % 2);\n&#125;, [arr]);\n\nuseCallback 与 useMemo 区别' useCallback和useMemo的区别\n// todo useCallback是真正的缓存函数\n// todo useMemo缓存的是函数的返回值\n' useCallback和useMemo能否相互转换\n// todo 只有useCallback可以写成useMemo，将之前的函数当作返回值，柯里化函数\n const fn2 = useMemo(() => &#123;\n    return () => &#123;\n      console.log(\"do something\");\n    &#125;;\n  &#125;, []);\n\nuseContext 【代替 Consumer 的作用】import React, &#123; createContext, useContext &#125; from \"react\";\n// todo useContext只能代替Consumer的作用\n// todo 里面需要传入context对象, 返回value对象\n\nconst context1 = createContext();\nconst context2 = createContext();\n\nconst Child2 = () => &#123;\n  const &#123; name &#125; = useContext(context1); // 传入context对象, 返回value对象 name\n  const &#123; nick &#125; = useContext(context2); // 传入context对象, 返回value对象 nick\n  return (\n    &lt;div>\n      child2组件 - &#123;name&#125; - &#123;nick&#125;\n      &#123;/* &lt;context1.Consumer>\n        &#123;(value) => (\n          &lt;span>\n            &#123;value.name&#125; -&#123;\" \"&#125;\n            &lt;context2.Consumer>\n              &#123;(val) => &lt;span>&#123;val.nick&#125;&lt;/span>&#125;\n            &lt;/context2.Consumer>\n          &lt;/span>\n        )&#125;\n      &lt;/context1.Consumer> */&#125;\n    &lt;/div>\n  );\n&#125;;\n\nuseReducer 【redux 的阉割版，只能做同步】【返回数组】import React, &#123; useReducer &#125; from \"react\";\n\nconst defaultState = &#123;\n  count: 1,\n&#125;;\n\nconst reducer = (state, action) => &#123;\n  switch (action.type) &#123;\n    case \"add\":\n      return &#123;\n        ...state,\n        count: state.count + 1,\n      &#125;;\n    case \"minus\":\n      return &#123;\n        ...state,\n        count: state.count - 1,\n      &#125;;\n    default:\n      return state;\n  &#125;\n&#125;;\n\nconst App = () => &#123;\n  // todo useReducer需要传入两个参数\n  // todo 返回值是一个数组\n  const [state, dispatch] = useReducer(reducer, defaultState);\n\n  return (\n    &lt;>\n      &lt;h2>useReducer&lt;/h2>\n      &lt;span>&#123;state.count&#125;&lt;/span>\n      &lt;button onClick=&#123;() => dispatch(&#123; type: \"add\" &#125;)&#125;>btn&lt;/button>\n    &lt;/>\n  );\n&#125;;\n\nexport default App;\n\nuseRef 【来定义变量，可以绕过捕获值的特性】【变量是没有响应式】// todo 还可以用useRef来定义变量，可以绕过捕获值的特性\n// todo 用useRef定义的变量是没有响应式\nimport React, &#123; useRef &#125; from \"react\";\nfunction App() &#123;\n  const count = useRef(1);\n\n  const showCount = () => &#123;\n    console.log(\"count: \" + count.current);\n  &#125;;\n\n  const handleClick = (number) => &#123;\n    count.current = count.current + number;\n    setTimeout(showCount, 2000);\n  &#125;;\n\n  return (\n    &lt;div>\n      &lt;p>You clicked &#123;count.current&#125; times&lt;/p>\n      &lt;button onClick=&#123;() => handleClick(1)&#125;>增加 count&lt;/button>\n      &lt;button onClick=&#123;() => handleClick(-1)&#125;>减少 count&lt;/button>\n    &lt;/div>\n  );\n&#125;\nexport default App;\n\nuseImperativeHandle 【用于让父组件获取子组件内的索引】forwardRef() 【创建一个 React 组件, 可以把上级 ref 转发(传递) 给下级组件, 继而可以在上级组件中获取下级目标】import React, &#123;\n  useRef,\n  useEffect,\n  useImperativeHandle,\n  forwardRef,\n&#125; from \"react\";\n\nfunction ChildInputComponent(props, ref) &#123;\n  const inputRef = useRef(null);\n  useImperativeHandle(ref, () => inputRef.current);\n  return &lt;input type=\"text\" name=\"child input\" ref=&#123;inputRef&#125; />;\n&#125;\n\nconst ChildInput = forwardRef(ChildInputComponent); // 转发ref 节点\n\nfunction App() &#123;\n  const inputRef = useRef(null);\n  useEffect(() => &#123;\n    inputRef.current.focus(); // 子组件的Input框聚焦了\n  &#125;, []);\n  return (\n    &lt;div>\n      &lt;ChildInput ref=&#123;inputRef&#125; />\n    &lt;/div>\n  );\n&#125;\n\nexport default App;\n\n自定义 hooks 【类似模块化开发，将可以复用的功能方法放在外面】 【相同功能的代码放到了一起，方便阅读和维护】import &#123; useState &#125; from \"react\";\n\nconst useCounter = () => &#123;\n  const [count, setCount] = useState(1);\n  const fn1 = () => &#123;\n    setCount((v) => v - 1);\n  &#125;;\n  const fn2 = () => &#123;\n    setCount((v) => v + 1);\n  &#125;;\n\n  return [count, fn1, fn2]; // 组件需要啥就输出啥\n&#125;;\n\nexport default useCounter;\n\nimport React from \"react\";\n\nimport useCounter from \"./utils/useCounter\";\n\n// todo 自定义hooks\n// todo 相同功能的代码放到了一起，方便阅读和维护\n// todo 可以复用\n\n// todo 显示当前事件 / 文件上传功能 / 倒计时\n\nconst App = () => &#123;\n  const [count, fn1, fn2] = useCounter();\n  return (\n    &lt;>\n      &lt;h2>自定义hooks&lt;/h2>\n      &lt;button onClick=&#123;fn1&#125;>-&lt;/button>\n      &lt;span>&#123;count&#125;&lt;/span>\n      &lt;button onClick=&#123;fn2&#125;>+&lt;/button>\n\n      &lt;p>当前事件为: &#123;nowTime&#125;&lt;/p>\n    &lt;/>\n  );\n&#125;;\n\nexport default App;\n\n\n","slug":"React学习总结( 六 ) 【 immutable 与 hooks 】","date":"2022-12-26T13:14:11.604Z","categories_index":"React","tags_index":"React笔记","author_index":"LCS's Blog"},{"id":"0b9255324d1752fc31147db2449c0610","title":"React小记（一）","content":"React 学习总结（一）1、组件中的 DOM 样式\n第一种：行内样式// 注意这里的两个括号，第一个表示我们在要JSX里插入JS了，第二个是对象的括号\n &lt;p style=&#123;&#123;color:'red', fontSize:'14px'&#125;&#125;>Hello world&lt;/p>\n\n第二种：class 样式引入import \"./02-style.css\";//引入写好的样式\n&lt;h2>class添加样式&lt;/h2>\n&#123;/* class属性，要写成className */&#125;\n&lt;p className=\"font\" id=\"abc\">hello react!!!&lt;/p>\n\n第三种：styled-componentsstyled-components是针对 React 写的一套 css-in-js 框架，简单来讲就是在 js 中写 css。\nimport styled from \"styled-components\";\nconst BlueBig = styled.p`\n  color: blue;\n  /* font-size: 50px; */\n  font-size: $&#123;(props) => props.size&#125;px; //可进行处理\n`;\n\n第四种：classnames【不同的条件添加不同的样式】有时候需要根据不同的条件添加不同的样式，比如：完成状态，完成是绿色，未完成是红色。那么这种情况下，我们推荐使用classnames这个包：\n//! 引入classNames，用于不同的条件添加不同的样式\nimport classNames from \"classnames/bind\";\nimport styles from \"./03-style.css\";\nlet cx = classNames.bind(styles);\nconst Child = (props) => &#123;\n  let className = cx(&#123;\n    // key表示类名，value表示变量或者表达式\n    green: props.num === \"1\",\n    red: props.num === \"2\",\n    big: true,\n  &#125;);\n  return (\n    // &lt;div className=&#123;props.num === \"1\" ? \"green\" : \"red\"&#125;>\n    &lt;div className=&#123;className&#125;>hello react!! - &#123;props.num&#125;&lt;/div>\n  );\n&#125;;\n\n2、受控组件和非受控组件\n受控组件：如果将React里的state属性和表单元素的值建立依赖关系，再通过onChange事件与setState()结合更新state属性，就能达到控制用户输入过程中表单发生的操作。被React以这种方式控制取值的表单输入元素就叫做受控组件\n&lt;h2>form表单&lt;/h2>\n        &lt;input\n          type=\"text\"\n          value=&#123;this.state.textVlaue&#125;\n          onChange=&#123;this.handleChange1&#125;\n        />\n        &lt;hr />\n        &lt;textarea\n          value=&#123;this.state.areaValue&#125;\n          onChange=&#123;this.handleChange2&#125;\n        >&lt;/textarea>\n        &lt;hr />\n        &lt;select value=&#123;this.state.selectValue&#125; onChange=&#123;this.handleChange3&#125;>\n          &lt;option value=\"\" disabled>//disabled 不能被选择\n            -- 请选择 --\n          &lt;/option>\n          &lt;option value=\"1\">男&lt;/option>\n          &lt;option value=\"2\">女&lt;/option>\n          &lt;option value=\"0\">未知&lt;/option>\n        &lt;/select>\n        &lt;hr />\n        我已阅读&#123;\" \"&#125;\n        &lt;input\n          type=\"checkbox\"\n          checked=&#123;this.state.checked&#125;\n          onChange=&#123;this.handleChange4&#125;\n        />\n        &lt;hr />\n        &lt;button onClick=&#123;this.handleClick&#125;>btn&lt;/button>\n\n非受控组件：input标签它实际也是一个DOM元素，我们可以用获取DOM元素信息的方式来获取表单元素的值呢？也就是使用 ref 来从 DOM 节点中获取表单数据。【有三种获取 DOM 节点的写法】\n关键代码： ipt = createRef();　　　　　 this.ipt.current 获取 DOM 元素\nimport React, &#123; Component, createRef &#125; from \"react\";\n //todo createRef用来做非受控组件的\n //todo createRef()返回的是一个地址引用\n  ipt = createRef();\nhandleClick() &#123;\n  // console.log(this.ipt.current);是input标签\n    console.log(this.ipt.current.value);//获取表单的值\n  &#125;\n   &#123;/* 非受控组件的初始值要用defaultValue */&#125;\n   &lt;input type=\"text\" ref=&#123;this.ipt&#125; defaultValue=\"abc\" />\n\n    // 箭头函数的写法获取input标签 (工作中用的多)\n     let &#123;inputDom&#125; = this //直接在实例中结构,就可以获取input标签了\n     &lt;input type=\"text\" ref=&#123;(currentNode) => this.inputDom = currentNode&#125; defaultValue=\"abc\" />\n    //要被废弃的一种,字符串形式ref打标识, 实例属性refs来收集,键值对形式\n     /   let &#123;input1&#125; = this.refs 获取input1标签\n     &lt;input type=\"text\" ref='input1' defaultValue=\"abc\" />\n\n3、setState\n接受一个对象的形式：如果改变后的值不需要依赖上一次的值，最好用对象，更加方便\n//todo 可以接收第一个参数是对象，第二个参数是回调函数，在改变结束以后调用\nthis.setState(\n  &#123;\n    count: 10,\n  &#125;,\n  () => &#123;\n    console.log(this.state.count);\n  &#125;\n);\n\nsetState 是可以接收一个函数, 第二个参数是回调函数：如果改变后的值需要依赖上一次的值，最好用函数，更加安全\nthis.setState(\n     (prevState，props) => &#123; //可以接收上一个数据和props值\n       return &#123;\n         count: prevState.count + 1,\n       &#125;;\n     &#125;,\n     () => &#123;\n       console.log(this.state.count);\n     &#125;\n   );\n\n4、状态提升（将公用数据放在父组件）\n理解：React的状态提升就是用户对子组件操作，子组件不改变自己的状态，通过自己的props把这个操作改变的数据传递给父组件，改变父组件的状态，从而改变受父组件控制的所有子组件的状态，这也是React单项数据流的特性决定的。\n\n官方的原话是：共享 state(状态) 是通过将其移动到需要它的组件的最接近的共同祖先组件来实现的。 这被称为“状态提升(Lifting State Up)”。\nclass App extends Component &#123;\n  state = &#123;\n    count: undefined,\n  &#125;;\n  getCount(count) &#123;\n    this.setState(&#123;\n      count,\n    &#125;);\n  &#125;\n  render() &#123;\n    return (\n      &lt;>\n        &lt;h2>状态提升 - &#123;this.state.count&#125;&lt;/h2>\n        &lt;Child1 onGetCount=&#123;this.getCount.bind(this)&#125; /> 数据方法都放在父组件，子组件调用即\n        可使用\n        &lt;Child2 count=&#123;this.state.count&#125; />\n      &lt;/>\n    );\n  &#125;\n&#125;\n\n5、this 的指向问题\n1、内联地使用 bind, 不是很推荐，bind 会产生新函数，会增加内存消耗\n&lt;button onClick=&#123;this.handleClick.bind(this)&#125;>btn&lt;/button>\n\n2、在 constructor 里面调用 this.xxx = this.xxx.bind(this); 比较推荐\nconstructor() &#123;\n    super();\n    this.handleClick = this.handleClick.bind(this);\n  &#125;\n\n3、箭头函数，箭头函数的 this 指向外层, 推荐\nhandleClick = () => &#123;\n  console.log(this.state.count);\n&#125;;\n\n6、事件传参问题\n1、使用内联的 bind(this, xxx), bind 会产生新函数，新函数不会自动调用，并且 bind 的第二个参数会作为新函数的第一个参数, 不推荐，会增加内存\nremove = (id, e) => &#123; // e 参数是event\n    console.log(id, e);\n  &#125;;//事件\n &lt;button onClick=&#123;this.remove.bind(this, item.id)&#125;>删除&lt;/button>\n\n2、使用内联的箭头函数，多套了一层，触发外层，里层自动执行, 不是特别推荐，因为会产生新函数增加内存, 但是这是项目里面用的最多的方式\n&lt;button onClick=&#123; (e) => this.remove(item.id, e) &#125;>删除&lt;/button> e 参数是event\nremove = (id, e) => &#123;\n   console.log(id, e);\n &#125;;//事件\n\n3、 柯里化函数，外层自动调用，里层点击后调用, 最推荐的方式\nremove = (id, num) => (e) => &#123;\n  e.stopPropagation(); //阻止事件冒泡\n  console.log(id, e, num); // e 为event\n&#125;;\n&lt;button onClick=&#123;this.remove(item.id, 123)&#125;>删除&lt;/button>;\n\n7、createContext 【跨组件通信】\n关键代码：{ Provider, Consumer } = createContext()\n在 react 没有类似 vue 中的事件总线来解决这个问题，我们只能借助它们共同的父级组件来实现，将非父子关系装换成多维度的父子关系。react 提供了context api 来实现跨组件通信, React 16.3 之后的contextapi 较之前的好用。\n// todo 引入createContext，用于跨组件通信\nimport React, &#123; Component, createContext &#125; from \"react\";\n// todo 执行以后会返回context对象\nconst context = createContext();\n// todo  提供者    消费者 export暴露组件，可以给需要的组件用\nexport const &#123; Provider, Consumer &#125; = context;\n// todo Provider使用的时候需要又一个属性value，包在父级的&lt;>&lt;/>\n&lt;Provider\n  value=&#123;&#123;\n    count: 123,\n    name: this.state.name,\n  &#125;&#125;\n>\n  &lt;Child />\n&lt;/Provider>;\n// todo Consumer里面需要写一个函数，函数可以接收一个value参数，需要返回jsx\n// todo import后面的解构用as取别名，普通对象用冒号取别名\nimport &#123; Consumer as Abc &#125; from \"./App\";\n&lt;div>\n  child组件 -\n  &lt;Consumer>\n    &#123;\" \"&#125;\n    //可以用别名，Abc\n    &#123;(value) => (\n      &lt;span>\n        &#123;value.count&#125; - &#123;value.name&#125;\n      &lt;/span>\n    )&#125;\n  &lt;/Consumer>\n&lt;/div>;\n\n父子组件通信1.父组件将自己的状态传递给子组件，子组件当做属性来接收，当父组件更改自己状态的时候，子组件接收到的属性就会发生改变\n2.父组件利用ref对子组件做标记，通过调用子组件的方法以更改子组件的状态,也可以调用子组件的方法..\n子组件与父组件通信\n父组件将自己的某个方法传递给子组件，在方法里可以做任意操作，比如可以更改状态，子组件通过this.props接收到父组件的方法后调用\n——–未完待续———-","slug":"React学习总结（一）","date":"2022-12-26T13:14:11.604Z","categories_index":"React","tags_index":"React笔记","author_index":"LCS's Blog"},{"id":"25f4b03abe20cfcdd61d2d9469f9b7df","title":"React小记【Redux异步库与模块化】","content":"Redux 异步库与模块化（Redux-saga)\n安装初始化后创建 sagas.js 文件（负责协调那些复杂或者异步的操作）【使用了 generator 函数，redux-saga 让你可以用 同步的方式来写异步代码】\nimport &#123; takeEvery, put, call &#125; from \"redux-saga/effects\";\nimport &#123; ratedApi &#125; from \"../../../utils/api\";\n\nfunction* addAction(action) &#123;\n  // todo put相当于组件的dispatch\n  console.log(action);\n  yield put(&#123; type: \"add\", num: action.num &#125;);\n&#125;\n\nfunction* addload(action) &#123;\n  // todo put相当于组件的dispatch\n  // todo call做数据请求\n  console.log(action);\n  const res = yield call(ratedApi); // 同await用法\n  yield put(&#123; type: \"load\", payload: res.result &#125;);\n&#125;\nfunction* mySaga() &#123;\n  // todo takeEvery接收两个参数\n  // todo 分配type值\n  yield takeEvery(\"takeAdd\", addAction);\n  yield takeEvery(\"takeload\", addload);\n&#125;\n\nexport default mySaga;\n\nindex.js 总输出文件：\nimport &#123; legacy_createStore as createStore, applyMiddleware &#125; from \"redux\";\nimport reducer from \"./reducer\";\n// todo 引入saga\nimport createSagaMiddleware from \"redux-saga\";\nimport rootSaga from \"./sagas\"; // 引入总的saga.js文件\nconst sagaMiddleware = createSagaMiddleware(); //创建中间件实例\nconst store = createStore(reducer, applyMiddleware(sagaMiddleware)); //当作第二个参数传入\nsagaMiddleware.run(rootSaga); //运行起来\nexport default store;\n\n组件的使用：【useSelector, useDispatch】代替【connect 中间件】\n// todo useSelector, useDispatch用于将仓库的属性和方法映射到组件\nimport &#123; useSelector, useDispatch &#125; from \"react-redux\";\nconst count = useSelector((state) => state.city.count); //调用仓库的数据\nconst ratedList = useSelector((state) => state.city.ratedList); //调用仓库的数据\nconst dispatch = useDispatch(); // 调用仓库的方法\nuseEffect(() => &#123;\n  dispatch(&#123; type: \"takeLoad\", payload: &#123; a: 3 &#125; &#125;);\n  // eslint-disable-next-line []报错加上\n&#125;, [dispatch]);\n\nRedux 模块化\n将大的 store 仓库拆分多个小仓库，每个需要的子组件内部都可以创建 store 小仓库【只需创建 reducer 函数和 saga.js 异步文件】，再合并到总的 reducer 和 rootSaga\ncombineReducers    用来合并 reducer\nimport &#123; combineReducers &#125; from \"redux\";\n\nimport cityReducer from \"../pages/city/store/reducer\";\n\nconst reducer = combineReducers(&#123;\n  city: cityReducer,\n&#125;);\n\nexport default reducer;\n\nall 用于合并 sagas\nimport &#123; all &#125; from \"redux-saga/effects\";\n\nimport citySaga from \"../pages/city/store/sagas\";\n\nfunction* rootSaga() &#123;\n  yield all([citySaga()]);\n&#125;\n\nexport default rootSaga;\n\n子组件使用: 【同 vuex 的模块化一样，使用数据需要加上仓库名，方法不需要】\nconst ratedList = useSelector((state) => &#123;\n  return state.city.ratedList; // 加上仓库名称\n&#125;);\n\n\n","slug":"Redux异步库与模块化（Redux-saga)","date":"2022-12-26T13:14:11.604Z","categories_index":"React","tags_index":"React笔记","author_index":"LCS's Blog"},{"id":"37bd36721f8bec015e9d4d3d62e233ff","title":"React小记【Router 4.5】","content":"React 学习总结( 四 ) 【 路由系列】\nreact-router-dom(路由 4.5 版本)\n一、基础路由搭建\n相关技术点：\n\n安装路由，解构出 BrowserRouter 套住需要路由的根组件\nimport &#123; BrowserRouter as Router &#125; from \"react-router-dom\";\nroot.render(\n  &lt;Router>\n    &lt;App />\n  &lt;/Router>\n);\n解构 Link, Route, Switch,j 加入 exact 精确匹配\n//  Link相当于改变url的a标签，对应vue里面router-link\n//  一个Route表示一个路由\n//  Switch是将包容性转成排他性路由\nimport &#123; Link, Route, Switch &#125; from \"react-router-dom\";\n// 路由组件\nclass Home extends Component &#123;\n  render() &#123;\n    return &lt;div>这是首页页面&lt;/div>;\n  &#125;\n&#125;\nclass About extends Component &#123;\n  render() &#123;\n    return &lt;div>这是关于页面&lt;/div>;\n  &#125;\n&#125;\nclass Mine extends Component &#123;\n  render() &#123;\n    return &lt;div>这是我的页面&lt;/div>;\n  &#125;\n&#125;\n// 父组件部分\nclass App extends Component &#123;\n  render() &#123;\n    return (\n      &lt;>\n        &lt;h2>react-router-basic&lt;/h2>\n        &lt;ul>\n          &lt;li>\n            &lt;Link to=\"/\">home&lt;/Link>\n          &lt;/li>\n          &lt;li>\n            &lt;Link to=\"/about\">about&lt;/Link>\n          &lt;/li>\n          &lt;li>\n            &lt;Link to=\"/mine\">mine&lt;/Link>\n          &lt;/li>\n        &lt;/ul>\n        &lt;hr />\n\n        &#123;/* react路由默认是包容性路由 */&#125;\n        &#123;/* exact表示精确匹配,默认是模糊匹配 */&#125;\n        &#123;/*设置path跳转路径，compoenet注册路由组件 */&#125;\n        &lt;Switch>\n          &lt;Route path=\"/\" component=&#123;Home&#125; exact>&lt;/Route>\n          &lt;Route path=\"/about\" component=&#123;About&#125;>&lt;/Route>\n          &lt;Route path=\"/mine\" component=&#123;Mine&#125;>&lt;/Route>\n        &lt;/Switch>\n      &lt;/>\n    );\n  &#125;\n&#125;\n\nexport default App;\n\n二、动态路由 【history 用来做编程式导航, location 用来获取 url 信息, match 用来获取参数】\n核心技术点：路径 / :id 获取路由信息，通过 props 的 match 用来获取参数\n组件部分：\n\n组件获取 ID 方法\n这是详情页面 - {this.props.match.params.id}-{this.props.match.params.str}\n\nclass Detail extends Component &#123;\n  render() &#123;\n    // todo 当一个组件通过路由引入的时候，props就是一个对象\n    // todo history用来做编程式导航, location用来获取url信息, match用来获取参数\n    // todo 统称为路由信息\n    // todo ?.叫做可选链操作符\n    console.log(this.props?.match?.params?.id);\n    // this.props.history.push?.();\n    return &lt;div>这是详情页面 - &#123;this.props.match.params.id&#125;&lt;/div>;\n  &#125;\n&#125;\nclass App extends Component &#123;\n  render() &#123;\n    return (\n      &lt;>\n        &lt;h2>react-router-params动态路由&lt;/h2>\n        &lt;ul>\n            &lt;Link to=\"/mine\">mine&lt;/Link>\n          &lt;/li>\n          &lt;li>\n            &lt;Link to=\"/detail/234\">detail&lt;/Link>\n          &lt;/li>\n        &lt;/ul>\n\n        &lt;hr />\n\n        &lt;Switch>\n          &lt;Route path=\"/about\" component=&#123;About&#125;>&lt;/Route>\n          &lt;Route path=\"/mine\" component=&#123;Mine&#125;>&lt;/Route>\n          &#123;/* 动态路由 */&#125;\n          &lt;Route path=\"/detail/:id\" component=&#123;Detail&#125;>&lt;/Route>\n        &lt;/Switch>\n      &lt;/>\n    );\n  &#125;\n&#125;\n\nexport default App;\n\n三、路由嵌套\n注意点:如果一个组件需要做嵌套路由，不能加 exact 精确匹配属性\n嵌套的方法很简单，直接在要嵌套的组件里继续写 Link 和 switch\nclass Home extends Component &#123;\n  render() &#123;\n    // console.log(this.props);\n    const &#123;\n      match: &#123; url &#125;,\n    &#125; = this.props; //做了而二次解构，把公共的url结构出来\n    return (\n      &lt;>\n        &lt;div>这是首页页面&lt;/div>\n        &lt;ul>\n          &lt;li>\n            &lt;Link to=&#123;`$&#123;url&#125;/home1`&#125;>home1&lt;/Link>&#123;\" \"&#125;\n            //模板字符串是JS表达式，需要加&#123;&#125;\n          &lt;/li>\n          &lt;li>\n            &lt;Link to=&#123;`$&#123;url&#125;/home2`&#125;>home2&lt;/Link>\n          &lt;/li>\n        &lt;/ul>\n\n        &lt;hr />\n\n        &lt;Switch>\n          &lt;Route path=&#123;`$&#123;url&#125;/home1`&#125; component=&#123;Home1&#125;>&lt;/Route>\n          &lt;Route path=&#123;`$&#123;url&#125;/home2`&#125; component=&#123;Home2&#125;>&lt;/Route>\n        &lt;/Switch>\n      &lt;/>\n    );\n  &#125;\n&#125;\n\n四、组件的渲染方式\n1.render 属性渲染组件 【主要渲染函数组件】【类组件需要套箭头函数】\n主要作用：函数可以进行逻辑判断，根据条件渲染，路由鉴权等….\n    &#123;/* render属性也可以渲染页面 */&#125;\n    &#123;/* render属性只能渲染函数组件，不能渲染类组件 */&#125;\n    &#123;/* render想渲染类组件，需要使用箭头函数, 但是路由信息是需要传递一下 */&#125;\n    &#123;/* render里面写函数，就可以写逻辑判断 */&#125;\n    &lt;Route\n      path=\"/about\"\n      render=&#123;(props) => &#123;\n        return &lt;About &#123;...props&#125; />;  /// 类组件渲染 &#123;...传递props&#125;\n       &#125;&#125;\n    >&lt;/Route>\n-----------// withRouter是一个高阶组件，作用就是让那些没有路由信息的组件，拥有路由信息---\n        import &#123; Link, Route, Switch, withRouter &#125; from \"react-router-dom\";\n\n\n2.children 属性渲染组件 【children 属性在有 Switch 的情况下和 render 是一样的，没有 Swtich 的情况下不管 url 是否匹配都会渲染】\n&#123;&#x2F;* children属性也可以做渲染 *&#x2F;&#125;\n&#123;&#x2F;* children属性在有Switch的情况下和render是一样的，没有Swtich的情况下不管url是否匹配都会渲染 *&#x2F;&#125;\n&lt;Route path&#x3D;&quot;&#x2F;mine&quot; children&#x3D;&#123;Mine&#125;&gt;&lt;&#x2F;Route&gt;\n\n3.插槽渲染 【既能渲染函数组件也能渲染类组件】 【缺点：没有路由信息,可以用 withRouter 高阶组件解决，但是会让组件树套的更深】\n&#123;&#x2F;* 也可以使用插槽的方式直接写在Route的里面 *&#x2F;&#125;\n&#123;&#x2F;* 既能渲染函数组件也能渲染类组件 *&#x2F;&#125;\n&#123;&#x2F;* 但是插槽的方式是没有路由信息的 *&#x2F;&#125;\n&lt;Route path&#x3D;&quot;&#x2F;classify&quot;&gt;\n  &lt;Classify &#x2F;&gt;\n&lt;&#x2F;Route&gt;\n &#x2F;&#x2F; withRouter是一个高阶组件，作用就是让那些没有路由信息的组件，拥有路由信息---\n    import &#123; Link, Route, Switch, withRouter &#125; from &quot;react-router-dom&quot;;\n    @withRouter\n      class Classify extends Component &#123;\n         render() &#123;\n         console.log(this.props);\n         return &lt;div&gt;这是分类页面&lt;&#x2F;div&gt;;\n         &#125;\n       &#125;\n\n4.component 【既能渲染函数组件也能渲染类组件，比较常见的渲染方式】\n&#123;&#x2F;* 渲染页面比较常用的方式是使用component属性 *&#x2F;&#125;\n&#123;&#x2F;* component既能渲染函数组件也能渲染类组件 *&#x2F;&#125;\n&lt;Route path&#x3D;&quot;&#x2F;home&quot; component&#x3D;&#123;Home&#125;&gt;&lt;&#x2F;Route&gt;\n\n五、Redirect 重定向 【是和 Route 并列的地方 使用 Redirect 的时候要加上 exact】\nimport React, &#123; Component &#125; from \"react\";\nimport &#123; Link, Route, Switch, Redirect &#125; from \"react-router-dom\";\n\nclass Home extends Component &#123;\n  render() &#123;\n    return &lt;div>这是首页页面&lt;/div>;\n  &#125;\n&#125;\n\nclass About extends Component &#123;\n  render() &#123;\n    return &lt;div>这是关于页面&lt;/div>;\n  &#125;\n&#125;\n\nclass Mine extends Component &#123;\n  render() &#123;\n    return &lt;div>这是我的页面&lt;/div>;\n  &#125;\n&#125;\n\nclass App extends Component &#123;\n  render() &#123;\n    return (\n      &lt;>\n        &lt;h2>react-router-重定向&lt;/h2>\n        &lt;ul>\n          &lt;li>\n            &lt;Link to=\"/home\">home&lt;/Link>\n          &lt;/li>\n          &lt;li>\n            &lt;Link to=\"/about\">about&lt;/Link>\n          &lt;/li>\n          &lt;li>\n            &lt;Link to=\"/mine\">mine&lt;/Link>\n          &lt;/li>\n        &lt;/ul>\n\n        &lt;hr />\n\n        &#123;/* Redirect表示重定向，是和Route并列的地方 */&#125;\n        &#123;/* from类似于path(匹配)的效果 */&#125;\n        &#123;/* 使用Redirect的时候要加上exact */&#125;\n        &lt;Switch>\n          &lt;Redirect from=\"/\" to=\"/home\" exact>&lt;/Redirect>\n          &lt;Route path=\"/home\" component=&#123;Home&#125;>&lt;/Route>\n          &lt;Route path=\"/about\" component=&#123;About&#125;>&lt;/Route>\n          &lt;Route path=\"/mine\" component=&#123;Mine&#125;>&lt;/Route>\n        &lt;/Switch>\n      &lt;/>\n    );\n  &#125;\n&#125;\n\nexport default App;\n\n六、路由鉴权 【运用 withRouter 高阶函数获取路由信息】【缺点：会加深组件树】【可以使用 Hooks 解决】\nimport &#123; Link, Route, Switch, Redirect, withRouter &#125; from \"react-router-dom\";\n// 登录组件，以插槽形式渲染，没有路由信息，用withRouter高阶组件解决\nclass Login extends Component &#123;\n  fn = () => &#123;\n    localStorage.setItem(\"token\", \"grthrthrth\");\n    // 编程式导航\n    this.props.history.push(\"/home\");\n  &#125;;\n  render() &#123;\n    return (\n      &lt;div>\n        这是登录页面 - &lt;button onClick=&#123;this.fn&#125;>登录&lt;/button>\n      &lt;/div>\n    );\n  &#125;\n&#125;\n// ---鉴权组件封装---做到复用功能------\nclass Auth extends Component &#123;\n  render() &#123;\n    return (\n      &lt;Route\n        path=&#123;this.props.path&#125;\n        render=&#123;() => &#123;\n          if (localStorage.getItem(\"token\")) &#123;\n            return this.props.children;\n          &#125; else &#123;\n            return &lt;Redirect from=&#123;this.props.path&#125; to=\"/login\">&lt;/Redirect>;\n          &#125;\n        &#125;&#125;\n      >&lt;/Route>\n    );\n  &#125;\n&#125;\n// App\nclass App extends Component &#123;\n  render() &#123;\n    return (\n      &lt;>\n        &lt;h2>react-router-路由鉴权&lt;/h2>\n        &lt;ul>\n          &lt;li>\n            &lt;Link to=\"/home\">home&lt;/Link>\n          &lt;/li>\n          &lt;li>\n            &lt;Link to=\"/about\">about&lt;/Link>\n          &lt;/li>\n          &lt;li>\n            &lt;Link to=\"/mine\">mine&lt;/Link>\n          &lt;/li>\n        &lt;/ul>\n\n        &lt;hr />\n\n        &lt;Switch>\n          &lt;Redirect from=\"/\" to=\"/home\" exact>&lt;/Redirect>\n          &lt;Route path=\"/home\" component=&#123;Home&#125;>&lt;/Route>\n          &#123;/* &lt;Route path=\"/about\" component=&#123;About&#125;>&lt;/Route> */&#125;\n          &lt;Auth path=\"/about\">\n            &lt;About />\n          &lt;/Auth>\n          &#123;/* &lt;Route\n            path=\"/mine\"\n            render=&#123;() => &#123;\n              if (localStorage.getItem(\"token\")) &#123;\n                return &lt;Mine />;\n              &#125; else &#123;\n                return &lt;Redirect to=\"/login\">&lt;/Redirect>;\n              &#125;\n            &#125;&#125;\n          >&lt;/Route> */&#125;\n          &lt;Auth path=\"/mine\">\n            &lt;Mine />\n          &lt;/Auth>\n          &lt;Route path=\"/login\">\n            &#123;withRouter(Login)&#125; //有高阶组件包住，插槽方式渲染就有路由信息了\n          &lt;/Route>\n        &lt;/Switch>\n      &lt;/>\n    );\n  &#125;\n&#125;\n\n七、 NavLink 组件 【作用是包含了 Link 的全部的功能，除此之外，增加了高亮的作用】【activeClassName 用于替换高亮的类名，exact 精准匹配】\n【不添加 activeClassName 替换类名，默认就加了 className=’active’】\nimport &#123; NavLink, Route, Switch &#125; from \"react-router-dom\";\nimport \"./07-styles.css\"; //引入css样式\n// App部分\n        &lt;h2>react-router-路由高亮&lt;/h2>\n        &lt;ul>\n          &lt;li>\n            &lt;NavLink to=\"/\" activeClassName=\"select\" exact> // 直接使用类名\n              home\n            &lt;/NavLink>\n          &lt;/li>\n          &lt;li>\n            &lt;NavLink to=\"/about\" activeClassName=\"select\">\n              about\n            &lt;/NavLink>\n          &lt;/li>\n          &lt;li>\n            &lt;NavLink to=\"/mine\" activeClassName=\"select\">\n              mine\n            &lt;/NavLink>\n          &lt;/li>\n        &lt;/ul>\n\n八、Prompt 组件 【路由保护】【有 when 和 message 属性控制】\nimport &#123; Link, Route, Switch, Redirect, Prompt &#125; from \"react-router-dom\";\n// 案例，当input表单有内容的时候，进行跳转提示\nclass About extends Component &#123;\n  state = &#123;\n    value: \"\",\n  &#125;;\n  handleChange = (e) => &#123;\n    this.setState(&#123;\n      value: e.target.value,\n    &#125;);\n  &#125;;\n  render() &#123;\n    return (\n      &lt;>\n        &lt;div>这是关于页面&lt;/div>\n        &lt;input\n          type=\"text\"\n          value=&#123;this.state.value&#125;\n          onChange=&#123;this.handleChange&#125;\n        />\n\n        &lt;Prompt\n          when=&#123;！！this.state.value&#125; // when里面接收 布尔值\n          message=&#123;(location) => // 接收location参数，包含了当前路由信息\n          // &#123;pathname: '/mine', search: '?a=4&amp;b=8', hash: '', state: undefined, key: '7dibvy'&#125;\n            `Are you sure you want to go to $&#123;location.pathname&#125;`// url的跳转路径\n          &#125;\n        >&lt;/Prompt>\n      &lt;/>\n    );\n  &#125;\n&#125;\n        &lt;li>\n            &lt;Link to=\"/mine?a=4&amp;b=8\">mine&lt;/Link>   ///加search直接?x=x&amp;x=x\n          &lt;/li>\n       &lt;Switch>\n          &lt;Redirect from=\"/\" to=\"/home\" exact>&lt;/Redirect>\n          &lt;Route path=\"/home\" component=&#123;Home&#125;>&lt;/Route>\n          &lt;Route path=\"/about/:id\" component=&#123;About&#125;>&lt;/Route>\n          &lt;Route path=\"/mine\" component=&#123;Mine&#125;>&lt;/Route>\n        &lt;/Switch>\n\n九、404 页面匹配 【必须和 Switch 一起用，只能写在所有 Route 的最后面 】\n// App的switch部分\n&lt;Switch>\n  &#123;/* 必须和 Switch一起用，只能写在所有Route的最后面 */&#125;\n  &lt;Redirect from=\"/\" to=\"/home\" exact>&lt;/Redirect>\n  &lt;Route path=\"/home\" component=&#123;Home&#125;>&lt;/Route>\n  &lt;Route path=\"/about\" component=&#123;About&#125;>&lt;/Route>\n  &lt;Route path=\"/mine\" component=&#123;Mine&#125;>&lt;/Route>\n  &lt;Route path=\"*\" component=&#123;NotFound&#125;>&lt;/Route>\n&lt;/Switch>\n\n十、params 路由信息 【获取 search 部分信息】\n相关方法：【const params = new URLSearchParams(search)】\nclass Mine extends Component &#123;\n  render() &#123;\n    &#x2F;&#x2F; console.log(this.props);\n    const &#123;\n      location: &#123; search &#125;,\n    &#125; &#x3D; this.props;\n    &#x2F;&#x2F; console.log(search);\n\n    const params &#x3D; new URLSearchParams(search);\n    console.log(params.get(&quot;a&quot;));\n    console.log(params.get(&quot;b&quot;));\n\n    return &lt;div&gt;这是我的页面&lt;&#x2F;div&gt;;\n  &#125;\n&#125;\nclass App extends Component &#123;\n  render() &#123;\n    return (\n      &lt;&gt;\n        &lt;h2&gt;react-router-参数&lt;&#x2F;h2&gt;\n        &lt;ul&gt;\n          &lt;li&gt;\n            &lt;Link to&#x3D;&quot;&#x2F;home&quot;&gt;home&lt;&#x2F;Link&gt;\n          &lt;&#x2F;li&gt;\n          &lt;li&gt;\n            &#123;&#x2F;* params传参 *&#x2F;&#125;\n            &lt;Link to&#x3D;&quot;&#x2F;about&#x2F;123&quot;&gt;about&lt;&#x2F;Link&gt;\n          &lt;&#x2F;li&gt;\n          &lt;li&gt;\n            &#123;&#x2F;* query传参 *&#x2F;&#125;\n            &lt;Link to&#x3D;&quot;&#x2F;mine?a&#x3D;3&amp;b&#x3D;4&quot;&gt;mine&lt;&#x2F;Link&gt;\n          &lt;&#x2F;li&gt;\n          &lt;li&gt;\n            &lt;Link\n              to&#x3D;&#123;&#123; &#x2F;&#x2F; 写成对象，就是location属性\n                pathname: &quot;&#x2F;detail&quot;,\n                search: &quot;?x&#x3D;10&amp;y&#x3D;20&quot;,\n                hash: &quot;#lll&quot;,\n                &#x2F;&#x2F; state可以写任意对象\n                state: &#123; str: &quot;hello&quot; &#125;,\n              &#125;&#125;\n            &gt;\n              detail\n            &lt;&#x2F;Link&gt;\n          &lt;&#x2F;li&gt;\n        &lt;&#x2F;ul&gt;\n\n        &lt;hr &#x2F;&gt;\n\n        &lt;Switch&gt;\n          &lt;Redirect from&#x3D;&quot;&#x2F;&quot; to&#x3D;&quot;&#x2F;home&quot; exact&gt;&lt;&#x2F;Redirect&gt;\n          &lt;Route path&#x3D;&quot;&#x2F;home&quot; component&#x3D;&#123;Home&#125;&gt;&lt;&#x2F;Route&gt;\n          &lt;Route path&#x3D;&quot;&#x2F;about&#x2F;:id&quot; component&#x3D;&#123;About&#125;&gt;&lt;&#x2F;Route&gt;\n          &lt;Route path&#x3D;&quot;&#x2F;mine&quot; component&#x3D;&#123;Mine&#125;&gt;&lt;&#x2F;Route&gt;\n          &lt;Route path&#x3D;&quot;&#x2F;detail&quot; component&#x3D;&#123;Detail&#125;&gt;&lt;&#x2F;Route&gt;\n        &lt;&#x2F;Switch&gt;\n      &lt;&#x2F;&gt;\n    );\n  &#125;\n&#125;\n\n十一、Hooks 【useHistory、 useLocation、useParams、useRouteMatch, useSearchParams 】【只能给函数组件用】\n增强函数组件的功能, 不会使组件树变深\n所有的 hooks 都要写在函数组件的顶层\n所有的 hooks 都是函数，都是 use 开头的\nimport &#123;\n  Link,\n  Switch,\n  Route,\n  useHistory,\n  useLocation,\n  useParams,\n  useRouteMatch,\n  useSearchParams\n&#125; from \"react-router-dom\";\nconst Home = () => &#123;\n  const history = useHistory();\n  const location = useLocation();\n  const params = useParams();\n  const match = useRouteMatch();\n  const [searchParams,setSearchParams] = useSearchParams();// 或取url search部分的键值对\n   console.log(searchParams.get(\"id\"));可以或许?id='xxxxx' 部分\n  const fn = () => &#123;\n    console.log(location);\n  &#125;;\n\n  return (\n    &lt;div>\n      这是home组件 - &lt;button onClick=&#123;fn&#125;>btn&lt;/button>\n    &lt;/div>\n  );\n&#125;;\n\n十二、路由表 【类似 vue 的路由表】\n\n建立路由表文件 【将原本的 App 导入，把路由组件写在这边，通过插槽创建路由层级，App proprs.children 接受，再导出到总文件】\nimport App from \"./App\"; //引入App父组件\nimport &#123; Route &#125; from \"react-router-dom\";\n\nimport Home from \"./pages/Home\";\nimport About from \"./pages/About\";\n\nimport Home1 from \"./pages/Home1\";\nimport Home2 from \"./pages/Home2\";\n\nconst Router = () => &#123;\n  return (\n    &lt;App>\n      &lt;Route path=\"/home\">\n        &lt;Home>\n          &lt;Route path=\"/home/home1\">\n            &lt;Home1 />\n          &lt;/Route>\n          &lt;Route path=\"/home/home2\">\n            &lt;Home2 />\n          &lt;/Route>\n        &lt;/Home>\n      &lt;/Route>\n      &lt;Route path=\"/about\">\n        &lt;About />\n      &lt;/Route>\n    &lt;/App>\n  );\n&#125;;\n\nexport default Router;\nApp 部分\nimport React from \"react\";\nimport &#123; Link, Switch &#125; from \"react-router-dom\";\n\nconst App = (props) => &#123;\n  return (\n    &lt;>\n      &lt;h2>router5-路由表&lt;/h2>\n      &lt;ul>\n        &lt;li>\n          &lt;Link to=\"/home\">home&lt;/Link>\n        &lt;/li>\n        &lt;li>\n          &lt;Link to=\"/about\">about&lt;/Link>\n        &lt;/li>\n      &lt;/ul>\n      &lt;hr />\n      &lt;Switch>&#123;props.children&#125;&lt;/Switch> / //类似vue的link-view,显示对应的路由页面\n    &lt;/>\n  );\n&#125;;\n\nexport default App;\n二级嵌套路由\nimport React from \"react\";\n\nimport &#123; Link, Switch &#125; from \"react-router-dom\";\n\nconst Home = (props) => &#123;\n  return (\n    &lt;>\n      &lt;div>这是首页页面&lt;/div>\n      &lt;ul>\n        &lt;li>\n          &lt;Link to=\"/home/home1\">home1&lt;/Link>\n        &lt;/li>\n        &lt;li>\n          &lt;Link to=\"/home/home2\">home2&lt;/Link>\n        &lt;/li>\n      &lt;/ul>\n\n      &lt;hr />\n\n      &lt;Switch>&#123;props.children&#125;&lt;/Switch>\n    &lt;/>\n  );\n&#125;;\n\nexport default Home;\n\n十三、Lazy 【 路由懒加载 】 【 lazy 函数、Suspense 包裹懒加载的组件、fallback 加载过程显示内容】\n\nApp 配置\nimport React, &#123; Component, lazy, Suspense &#125; from \"react\";\n// todo lazy就是用来做组件懒加载的\n// todo lazy需要配合Suspense一起使用\n\n// import Child from \"./Child\";\nconst Child = lazy(() => import(\"./Child\")); //lazy函数包裹需要做懒加载的子组件\n\nconst Loading = () => &#123;\n  return &lt;div>loading,,,,,&lt;/div>;\n&#125;;\n\nclass App extends Component &#123;\n  state = &#123;\n    show: false,\n  &#125;;\n  fn = () => &#123;\n    this.setState(&#123;\n      show: true,\n    &#125;);\n  &#125;;\n  render() &#123;\n    return (\n      &lt;>\n        &lt;h2>组件懒加载&lt;/h2>\n        &lt;button onClick=&#123;this.fn&#125;>btn&lt;/button>\n        &#123;/* fallback表示组件在加载的过程中显示的内容 */&#125;'\n        &lt;Suspense fallback=&#123;&lt;Loading />&#125;>\n          &#123;this.state.show &amp;&amp; &lt;Child />&#125;\n        &lt;/Suspense>\n      &lt;/>\n    );\n  &#125;\n&#125;\n\nexport default App;\n\n\n","slug":"React学习总结( 四 ) 【 路由4.5系列】","date":"2022-12-26T13:14:11.604Z","categories_index":"React","tags_index":"React笔记","author_index":"LCS's Blog"},{"id":"60c5a95c0e5d17fc3703202ce808ceda","title":"React小记【Redux】","content":"React 学习总结( 三 )1.什么是 redux?\nWeb 应用是一个状态机，视图与状态是一一对应的。\n所有的状态，保存在一个对象里面。\n// Redux是react中进行state状态管理的JS库（并不是react插件），一般是管理多个组件中共享数据状态。这个是和Vuex是一样的。\n\n首先明确一点，Redux 是一个有用的架构，但不是非用不可。事实上，大多数情况，你可以不用它，只用 React 就够了。\n\n曾经有人说过这样一句话：\n\n\"如果你不知道是否需要 Redux，那就是不需要它。\"\n\n\"只有遇到 React 实在解决不了的问题，你才需要 Redux 。\"\n\n2.Redux 仓库结构【legacy_createStore】\n\n3.legacy_createStore（作用和 vue 的 createStore 完全一样，执行可以返回一个仓库实例）\n使用流程：\n首先安装 redux 框架npm install redux --save\n创建 index.js 文件（需要用 node.js 启动该文件）\n结构出 legacy_createStore 【用 node 的 CommonJS 语法导入】const &#123; legacy_createStore &#125; = require(\"redux\");\n创建仓库原始数据const defaultState = &#123;\n  count: 3,\n  name: \"zhangmou\",\n&#125;;\n创建 reducer 函数, 用于改变 state//todo reducer需要传入两个参数, state,action\n//todo action是一个带有type属性的对象\n//todo reducer要满足纯函数的条件\nconst reducer = (state = defaultState, action) => &#123;\n  switch (action.type) &#123;\n    case \"add\":\n      return &#123;\n        ...state, // state原始数据始终没有被改变，返回一个新的对象覆盖原对象\n        count: state.count + 1,\n      &#125;;\n    case \"minus\":\n      return &#123;\n        ...state,\n        count: state.count - action.num,\n      &#125;;\n    default:\n      return state;\n  &#125;\n&#125;;\n'纯函数的概念：一个函数的返回结果只依赖其参数，并且执行过程中没有副作用，非异步，入参相同，出场必定相同\n\n//  非纯函数 返回值与a相关，无法预料\nconst a = 1\nconst foo = (b) => a + b\nfoo(2) // => 3\n\n// 纯函数 返回结果只依赖于它的参数 x 和 b，foo(1, 2) 只要 foo 代码不改变，你传入的参数是确定的，那么 foo(1, 2) 的值永远是可预料的。\nconst a = 1\nconst foo = (x, b) => x + b\nfoo(1, 2) // => 3\n创建 store 仓库实例//todo legacy_createStore执行可以返回一个仓库实例\n//todo 第一个参数是reducer的函数\nconst store = legacy_createStore(reducer);\nconsole.log(store); //生成了含有方法的对象 [dispath、subscribe、getState]\n &#123;\n   // dispatch用来调用reducer函数\n     dispatch: [Function: dispatch],\n  // subscribe用来监听仓库数据的改变\n    subscribe: [Function: subscribe],\n   // getState用于获取仓库数据\n    getState: [Function: getState],\n    replaceReducer: [Function: replaceReducer],\n    '@@observable': [Function: observable]\n  &#125;\n\n\nstore.dispatch（{type:xxxx}）调用 action，里面传入的对象就是 action\n\nstore.subscribe(callback 回调函数) 传入回调函数，用来监听仓库数据的改变\n\nstore.getState( ) 用于获取仓库数据\n//todo 表示仓库的原始数据\nconst defaultState = &#123;\n  count: 3,\n  name: \"zhangmou\",\n&#125;;\n//dispatch用来调用reducer函数\nconst reducer = (state = defaultState, action) => &#123;\n  // switch (action.type) &#123;\n  //   case \"add\":\n  //     return &#123;\n  //       ...state,\n  //       count: state.count + 1,\n  //     &#125;;\n  //   case \"minus\":\n  //     return &#123;\n  //       ...state,\n  //       count: state.count - action.num,\n  //     &#125;;\n  //   default:\n  //     return state;\n  // &#125;\n  //用对象字面量代替switch冗杂的语句\n  const obj = &#123;\n    add: &#123; ...state, count: state.count + 1 &#125;,\n    minus: &#123; ...state, count: state.count - action.num &#125;,\n    default: state,\n  &#125;;\n  return obj[action.type] || obj[\"default\"];\n&#125;;\nstore.dispatch(&#123; type: \"add\" &#125;); //&#123; count: 4, name: 'zhangmou' &#125;\nstore.dispatch(&#123; type: \"add\" &#125;); //&#123; count: 5, name: 'zhangmou' &#125;\nstore.dispatch(&#123; type: \"minus\", num: 3 &#125;); // &#123; count: 2, name: 'zhangmou' &#125;\n\n\n\n4.redux 与 react 结合实战\n一、同步方法\n单独创建 store 文件夹【index.js 创建仓库实例，reducer.js 写方法】\nimport &#123; legacy_createStore as createStore &#125; from \"redux\"; // as重命名\nimport reducer from \"./reducer.js\";//引入reducer函数\n\nconst store = createStore(reducer);\nexport default store;\n\n--------------'创建reducer函数---------\n //todo 表示仓库的原始数据\nconst defaultState = &#123;\n  count: 3,\n  name: \"zhangmou\",\n&#125;;\nconst reducer = (state = defaultState, action) => &#123;\n    const obj = &#123;\n    'add': &#123; ...state, count: state.count + 1 &#125;,\n    'minus': &#123; ...state, count: state.count - action.num &#125;,\n    'default': state\n  &#125;\n  return obj[action.type] || obj['default']\n&#125;\n\n​ 2.组件的 index.js 部分配置 【解构出 provider 提供者，引入 store 仓库实例，挂载到组件上，类似跨组件通信】\nimport &#123; Provider &#125; from \"react-redux\"; //解构出Provider,提供仓库数据\nimport store from \"./redux-todolist-async/redux\"; // 将创建好的仓库实例引入\nimport App from \"./redux-todolist-async/App\"; // App组件\nroot.render(\n  &lt;Provider store=&#123;store&#125;>\n    &#123;\" \"&#125;\n    // 包裹总组件，可以为所有组件提供服务，传入store数据\n    &lt;App />\n  &lt;/Provider>\n);\n\n​ 3.组件如何使用？【哪个组件需要，就在哪个组件解构出 connect 函数连通仓库，mapStateToProps 数据，mapDispatchToProps 方法】\n// todo connect需要接收两个参数，这两个参数都是函数, mapStateToProps[state数据],mapDispatchToProps[dispatch调用]\nimport &#123; connect &#125; from \"react-redux\";\nconst mapStateToProps = (state) => &#123;\n  return &#123;\n    count: state.count,\n  &#125;;\n&#125;;\nconst mapDispatchToProps = (dispatch) => &#123;\n  return &#123;\n    add(num) &#123;\n      dispatch(&#123; type: \"add\", num &#125;);\n    &#125;, // 可以写方法，dispatch调用仓库的reducer函数进行交互，可以从组件接受参数\n    minus() &#123;\n      dispatch(&#123; type: \"minus\" &#125;);\n    &#125;,\n  &#125;;\n&#125;;\nclass App extends Component &#123;\n  render() &#123;\n    console.log(this.props); // 将仓库的改变数据的方法映射到组件的props里面\n    return (\n      &lt;>\n        &lt;button onClick=&#123;() => this.props.add(2)&#125;>+1&lt;/button> //\n        this.props.xxx调用方法\n        &lt;span>&#123;this.props.count&#125;&lt;/span>\n        &lt;button onClick=&#123;() => this.props.minus()&#125;>-1&lt;/button>\n      &lt;/>\n    );\n  &#125;\n&#125;\n\nexport default \"connect(mapStateToProps,mapDispatchToProps)(App)\"; //connect是函数，返回函数，调用后将App当参数传递\n\n二、异步方法与同步的不同点: 使用 applyMiddleware 中间件接收一个异步库 thunk,异步库需安装\n仓库实例部分\n// 创建仓库实例\n// todo applyMiddleware中间件用于处理异步\nimport &#123; legacy_createStore as createStore, applyMiddleware &#125; from \"redux\";\nimport reducer from \"./reducer\";\n// todo 异步库\nimport thunk from \"redux-thunk\";\n\n// todo createStore还可以接收第二个参数, 就是中间件的返回值\n// todo applyMiddleware可以接收一个参数是异步库\nconst store = createStore(reducer, applyMiddleware(thunk));\nexport default store;\n额外创建 actionCreator.js 文件,【动作创建者】\nexport const minusAction = (id) => &#123;\n  // 需要暴露一下，需要的地方引入，还可以接收参数\n  // todo 使用了中间件以后，action里面就可以返回函数了，由中间件来帮助执行这个函数\n  // todo 这个函数可以使用dispatch参数\n  return (dispatch) => &#123;\n    setTimeout(() => &#123;\n      dispatch(&#123; type: \"remove\", id &#125;);\n    &#125;, 1000);\n  &#125;;\n&#125;;\nexport const addlist = () => &#123;\n  return (dispatch) => &#123;\n    fetch(\"http://www.pudge.wang:3080/api/rated/list\") //进行数据请求\n      .then((response) => response.json())\n      .then((res) => &#123;\n        dispatch(&#123; type: \"load\", list: res.result &#125;); //真正的dispatch调用action\n      &#125;);\n  &#125;;\n&#125;;\n组件如何使用？\n// 哪个组件需要直接引入动作创建者文件\nimport &#123;addlist&#125; from './redux/actionCreator'；\nimport &#123; connect &#125; from 'react-redux';\n\nconst mapDispatchToProps = (dispatch) => &#123;\n    return &#123;\n        addlist() &#123;\n            dispatch(addlist()) // dispatch调用的是异步函数的方法，不是直接调用action了，需要中转一下\n        &#125;\n    &#125;\n&#125;\n\n\n总结:\n总的与同步一样，多了中间件引用异步库，第一次 dispatch 调用的是异步库的函数进行中转第二次 dispatch 调用才是真正的 action,用法与同步相同\n\n\n\n","slug":"React学习总结( 三 ) 【 Redux 系列】","date":"2022-12-26T13:14:11.604Z","categories_index":"React","tags_index":"React笔记","author_index":"LCS's Blog"},{"id":"8af137cd21190334ea8f2f15702e9068","title":"gitlab 配置 ssh key","content":"gitlab 配置 ssh key打开本地 git bash 或者 cmd,使用如下命令生成ssh公钥和私钥对\nssh-keygen -t rsa -C &#39;xxx@xxx.com&#39; 然后一路回车(-C 参数是你的邮箱地址)\nssh-keygen\n\nEnter 一路回车,遇到 y 选 y\nC:\\Users\\LL&gt;ssh-keygen\nGenerating public&#x2F;private rsa key pair.\nEnter file in which to save the key (C:\\Users\\LL&#x2F;.ssh&#x2F;id_rsa):\nC:\\Users\\LL&#x2F;.ssh&#x2F;id_rsa already exists.\nOverwrite (y&#x2F;n)? y\nEnter passphrase (empty for no passphrase):\nEnter same passphrase again:\nYour identification has been saved in C:\\Users\\LL&#x2F;.ssh&#x2F;id_rsa.\nYour public key has been saved in C:\\Users\\LL&#x2F;.ssh&#x2F;id_rsa.pub.\nThe key fingerprint is:\nSHA256:TJf1AiiRDMYxs4bTcjOnIKrGn42s1yZfWIwRbrcIEHw ll\\ll@LL\nThe key&#39;s randomart image is:\n+---[RSA 3072]----+\n|.o..*&#x3D;.o .. .    |\n| ..Eo+&#x3D; .  + .   |\n|. *.B+.o. o . .  |\n|.. *o&#x3D;*o..   .   |\n|.   .o +S        |\n|o     o          |\n|.o  .. .         |\n|. oo+o.          |\n| .o&#x3D;+o           |\n+----[SHA256]-----+\n到此就是完成了！\n\n然后打开/.ssh/id_rsa.pub 文件(表示用户目录，比如我的 windows 就是 C:\\Users\\LL.ssh)，复制其中的内容\n打开 gitlab,找到 Profile Settings–&gt;SSH Keys—&gt;Add SSH Key,并把上一步中复制的内容粘贴到 Key 所对应的文本框，在 Title 对应的文本框中给这个 sshkey 设置一个名字，点击 Add key 按钮\n\n\n为啥要设置 ssh 协议呢？\n// 我们为什么要使用ssh协议呢？因为ssh更加安全，然后更加方便，比如我们公司的gitlab由http协议换成了https协议，那么如果你是使用http协议管理代码，那么需要修改所有的项目中的git地址变成https，这会把我们给逼疯的！但是如果我们一开始就是用ssh协议，这不需要任何的修改，简直不能再爽一点了。\n\n使用 GitBash 对 GitLab 服务器上的项目进行操作\n\n\n序号\n命令\n命令说明\n\n\n\n1\n$ git –version\n检查 Git 的版本\n\n\n2\n$ git config –global user.name “Coffee”\n提交信息时添加 Git 用户名\n\n\n3\n$ git config –global user.name\n验证输入的用户名\n\n\n4\n$ git config –global user.email “&#x78;&#120;&#120;&#x78;&#120;&#x40;&#49;&#x36;&#x33;&#x2e;&#99;&#111;&#109;“\n设置电子邮件地址\n\n\n5\n$ git config –global user.email\n验证输入的电子邮件地址\n\n\n6\n$ git config –global –list\n检查输入的信息\n\n\n7\n$ git checkout master\n获取对主分支所做的最新更改\n\n\n8\n$ git pull origin NAME-OF-BRANCH -u\n获取工作目录的最新更改(NAME-OF-BRANCH可以是’master’或任何其他现有的分支)\n\n\n9\n$ git checkout -b branch-name\n创建一个新的分支\n\n\n10\n$git clone 项目的 ssh 地址\n克隆项目到本地\n\n\nGitGit（读音为/gɪt/）是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。 [1] 也是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。\nGit 的作用是用于管理项目的源代码它主要用于管理 开发环境(Dev)下的项目代码\n市面上主要有两类源代码管理工具\n\n集中式代码管理工具 (svn)\n分布式代码管理工具 (git)\n\n官网https://git-scm.com/git 是一个跨平台的项目管理工具 可以运行在 Windows Linux Unix OSX\ngit 与 githubgit 是目前世界上最先进分布式的版本控制系统github 是一个仓库\ngit 基本操作全局用户配置# 每台计算机只需要执行一次配置\n$ git config --global user.name 'li xxx'\n$ git config --global user.email 'xxx@163.com'\n\n\n项目构建 在项目的根目录创建文件 (README.md .gitignore)\n在 .gitignore 中 存放需要忽略的文件或目录 (不需要 git 管理的文件或目录)\n在项目的根目录 执行 $ git init 进行仓库初始化操作\n进行项目初始化 $ npm init -y\n\n本地仓库操作# 查看状态   （查看文件是否被修改 被删除 或者添加）\n$ git status\n\n# 查看版本的差别\n$ git diff\n\n# 添加管理(将文件或目录添加到git本地仓库的暂存区)\n$ git add filename    # 添加文件到暂存区\n$ git add .           # 添加当前目录所有内容到暂存区\n$ git add path/       # 添加指定目录到暂存区\n$ git add --all       # 添加所有内容到暂存区\n\n# 将文件移出暂存区\n$ git rm --cached filename\n\n# 将暂存区的内容提交到本地仓库\n$ git commit -m 'message'    //这里的message可以是版本号\n\n# 查看提交日志\n$ git log\n\n# 回退一个版本\n$ git reset HEAD^\n\n# 回退到指定版本\n$ git reset --hard 提交记录的前6位\n\n# 查看帮助\n$ git --help\n\n# 恢复文件\n$ git checkout filename\n\n# 查看所有历史版本\n$ git reflog\n\n分支相关操作# 查看分支\n$ git branch\n\n# 创建分支\n$ git branch 分支名\n\n# 切换分支\n$ git checkout 分支名  或者    git switch 分支名\n\n# 创建并切换分支\n$ git checkout -b 分支名\n\n# 合并分支内容\n$ git merge 分支名\n\n# 删除分支\n$ git branch -d 分支名\n\n# 查看分支记录\n$ git log --graph --pretty=oneline\n\n# 直接拉取数据到对应的分支\n$ git pull origin master\n\n远程仓库操作# 生成密钥对 (公钥 / 私钥)\nssh-keygen -t rsa -C '里面输入邮箱地址'\n\n# 设置远程仓库地址\n$ git remote add origin https://github.com/jxsrzj0325/suning.com.git\n\n# 将本地仓库提交到远程仓库\n$ git push -u origin master\n\n# 查看所有源\n$ git remote\n\n# 查看源的路径\n$ git remote get-url 名称\n\n# 克隆仓库(下载 从无到有)\n$ git clone https://gitee.com/rootbk/suning.com.git\n\n# 拉取(已有 更新)\n$ git pull origin master\n\n组员的流程 （刚拿到项目时）\ngit clone xxxxxxxx (获取克隆的地址)\ngit checkout -b 分支名 (创建并切换分支)\ngit add . (存储内容到暂存区)\ngit commit -m “xxx” (将暂存区的内容提交到本地仓库)\ngit push –set-upstream origin 分支名 第一次需要如此上传\n\n组员的流程 （项目开始时）\ngit pull origin master 将远程的 master 拉到自己的 master\ngit checkout 分支名 (切换回到自己的分支)\ngit merge master ( 将自己的 master 合并到自己的分支 让分支是最新的)\n开始写代码 ing\ngit add . (存储内容到暂存区)\ngit commit -m “xxx2” (将暂存区的内容提交到本地仓库)\ngit pull origin master (将远程的最新的代码 拉到自己的分支)\n可能需要解决冲突(如果解决了冲突，需要重新 add 和 commit)\ngit push (上传)\n\n组长\n​ git fetch –all （查看所有分支）\n​ git checkout self （切换到相应组员分支）\n​ 启动项目并检查\n​ git checkout master （切换回主分支）\n​ git merge self （将检查无误的组员分支合并到主分支）\n​ git push (将本地的 master 推送到远程的 master)\n\n​ git checkout self\n​ git pull (将远程的 self 拉到本地的 self)\n​ 启动项目并检查\n​ git checkout master\n​ git merge self\n​ git push (将本地的 master 推送到远程的 master)\n","slug":"gitlab配置ssh key","date":"2022-12-26T13:14:11.604Z","categories_index":"gitlab","tags_index":"git","author_index":"LCS's Blog"},{"id":"6918b95b981bf0c727e4f883e20aa202","title":"关于vue3","content":"\n\n1.Vue3 简介\n2020 年 9 月 18 日，Vue.js 发布 3.0 版本，代号：One Piece（海贼王）\n耗时 2 年多、2600+次提交、30+个 RFC、600+次 PR、99 位贡献者\ngithub 上的 tags 地址：https://github.com/vuejs/vue-next/releases/tag/v3.0.0\n\n2.Vue3 带来了什么1.性能的提升\n打包大小减少 41%\n\n初次渲染快 55%, 更新渲染快 133%\n\n内存减少 54%\n……\n\n\n2.源码的升级\n使用 Proxy 代替 defineProperty 实现响应式\n\n重写虚拟 DOM 的实现和 Tree-Shaking\n……\n\n\n3.拥抱 TypeScript\nVue3 可以更好的支持 TypeScript\n\n4.新的特性\nComposition API（组合 API）\n\nsetup 配置\nref 与 reactive\nwatch 与 watchEffect\nprovide 与 inject\n……\n\n\n新的内置组件\n\nFragment\nTeleport\nSuspense\n\n\n其他改变\n\n新的生命周期钩子\ndata 选项应始终被声明为一个函数\n移除 keyCode 支持作为 v-on 的修饰符\n……\n\n\n\n一、创建 Vue3.0 工程1.使用 vue-cli 创建官方文档：https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create\n## 查看@vue/cli版本，确保@vue/cli版本在4.5.0以上\nvue --version\n## 安装或者升级你的@vue/cli\nnpm install -g @vue/cli\n## 创建\nvue create vue_test\n## 启动\ncd vue_test\nnpm run serve\n\n2.使用 vite 创建官方文档：https://v3.cn.vuejs.org/guide/installation.html#vite\nvite 官网：https://vitejs.cn\n\n什么是 vite？—— 新一代前端构建工具。\n优势如下：\n开发环境中，无需打包操作，可快速的冷启动。\n轻量快速的热重载（HMR）。\n真正的按需编译，不再等待整个应用编译完成。\n\n\n传统构建 与 vite 构建对比图\n\n -->\n\n## 创建工程\nnpm init vite-app &lt;project-name>\n## 进入工程目录\ncd &lt;project-name>\n## 安装依赖\nnpm install\n## 运行\nnpm run dev\n\n二、常用 Composition API官方文档: https://v3.cn.vuejs.org/guide/composition-api-introduction.html\n1.拉开序幕的 setup\n理解：Vue3.0 中一个新的配置项，值为一个函数。\nsetup 是所有Composition API（组合 API）“ 表演的舞台 ”。\n组件中所用到的：数据、方法等等，均要配置在 setup 中。\nsetup 函数的两种返回值：\n若返回一个对象，则对象中的属性、方法, 在模板中均可以直接使用。（重点关注！）\n若返回一个渲染函数：则可以自定义渲染内容。（了解）\n\n\n注意点：\n尽量不要与 Vue2.x 配置混用\nVue2.x 配置（data、methos、computed…）中可以访问到setup 中的属性、方法。\n但在 setup 中不能访问到Vue2.x 配置（data、methos、computed…）。\n如果有重名, setup 优先。\n\n\nsetup 不能是一个 async 函数，因为返回值不再是 return 的对象, 而是 promise, 模板看不到 return 对象中的属性。（后期也可以返回一个 Promise 实例，但需要 Suspense 和异步组件的配合）\n\n\n\n2.ref 函数\n作用: 定义一个响应式的数据\n语法: const xxx = ref(initValue)\n创建一个包含响应式数据的引用对象（reference 对象，简称 ref 对象）。\nJS 中操作数据： xxx.value\n模板中读取数据: 不需要.value，直接：&lt;div&gt;&#123;&#123;xxx&#125;&#125;&lt;/div&gt;\n\n\n备注：\n接收的数据可以是：基本类型、也可以是对象类型。\n基本类型的数据：响应式依然是靠Object.defineProperty()的get与set完成的。\n对象类型的数据：内部 “ 求助 ” 了 Vue3.0 中的一个新函数—— reactive函数。\n\n\n\n3.reactive 函数\n作用: 定义一个对象类型的响应式数据（基本类型不要用它，要用ref函数）\n语法：const 代理对象= reactive(源对象)接收一个对象（或数组），返回一个代理对象（Proxy 的实例对象，简称 proxy 对象）\nreactive 定义的响应式数据是“深层次的”。\n内部基于 ES6 的 Proxy 实现，通过代理对象操作源对象内部数据进行操作。\n\n4.Vue3.0 中的响应式原理vue2.x 的响应式\n实现原理：\n\n对象类型：通过Object.defineProperty()对属性的读取、修改进行拦截（数据劫持）。\n\n数组类型：通过重写更新数组的一系列方法来实现拦截。（对数组的变更方法进行了包裹）。\nObject.defineProperty(data, \"count\", &#123;\n  get() &#123;&#125;,\n  set() &#123;&#125;,\n&#125;);\n\n\n存在问题：\n\n新增属性、删除属性, 界面不会更新。\n直接通过下标修改数组, 界面不会自动更新。\n\n\n\nVue3.0 的响应式\n实现原理:\n\n通过 Proxy（代理）: 拦截对象中任意属性的变化, 包括：属性值的读写、属性的添加、属性的删除等。\n\n通过 Reflect（反射）: 对源对象的属性进行操作。\n\nMDN 文档中描述的 Proxy 与 Reflect：\n\nProxy：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy\n\nReflect：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect\nnew Proxy(data, &#123;\n  // 拦截读取属性值\n  get(target, prop) &#123;\n    return Reflect.get(target, prop);\n  &#125;,\n  // 拦截设置属性值或添加新属性\n  set(target, prop, value) &#123;\n    return Reflect.set(target, prop, value);\n  &#125;,\n  // 拦截删除属性\n  deleteProperty(target, prop) &#123;\n    return Reflect.deleteProperty(target, prop);\n  &#125;,\n&#125;);\n\nproxy.name = \"tom\";\n\n\n\n\n\n5.reactive 对比 ref\n从定义数据角度对比：\nref 用来定义：基本类型数据。\nreactive 用来定义：对象（或数组）类型数据。\n备注：ref 也可以用来定义对象（或数组）类型数据, 它内部会自动通过reactive转为代理对象。\n\n\n从原理角度对比：\nref 通过Object.defineProperty()的get与set来实现响应式（数据劫持）。\nreactive 通过使用Proxy来实现响应式（数据劫持）, 并通过Reflect操作源对象内部的数据。\n\n\n从使用角度对比：\nref 定义的数据：操作数据需要.value，读取数据时模板中直接读取不需要.value。\nreactive 定义的数据：操作数据与读取数据：均不需要.value。\n\n\n\n6.setup 的两个注意点\nsetup 执行的时机\n在 beforeCreate 之前执行一次，this 是 undefined。\n\n\nsetup 的参数\nprops：值为对象，包含：组件外部传递过来，且组件内部声明接收了的属性。\ncontext：上下文对象\nattrs: 值为对象，包含：组件外部传递过来，但没有在 props 配置中声明的属性, 相当于 this.$attrs。\nslots: 收到的插槽内容, 相当于 this.$slots。\nemit: 分发自定义事件的函数, 相当于 this.$emit。\n\n\n\n\n\n7.计算属性与监视1.computed 函数\n与 Vue2.x 中 computed 配置功能一致\n\n写法\nimport &#123;computed&#125; from 'vue'\n\nsetup()&#123;\n    ...\n\t//计算属性——简写\n    let fullName = computed(()=>&#123;\n        return person.firstName + '-' + person.lastName\n    &#125;)\n    //计算属性——完整\n    let fullName = computed(&#123;\n        get()&#123;\n            return person.firstName + '-' + person.lastName\n        &#125;,\n        set(value)&#123;\n            const nameArr = value.split('-')\n            person.firstName = nameArr[0]\n            person.lastName = nameArr[1]\n        &#125;\n    &#125;)\n&#125;\n\n2.watch 函数\n与 Vue2.x 中 watch 配置功能一致\n\n两个小“坑”：\n\n监视 reactive 定义的响应式数据时：oldValue 无法正确获取、强制开启了深度监视（deep 配置失效）。\n监视 reactive 定义的响应式数据中某个属性时：deep 配置有效。\n\n//情况一：监视ref定义的响应式数据\nwatch(\n  sum,\n  (newValue, oldValue) => &#123;\n    console.log(\"sum变化了\", newValue, oldValue);\n  &#125;,\n  &#123; immediate: true &#125;\n);\n\n//情况二：监视多个ref定义的响应式数据\nwatch([sum, msg], (newValue, oldValue) => &#123;\n  console.log(\"sum或msg变化了\", newValue, oldValue);\n&#125;);\n\n/* 情况三：监视reactive定义的响应式数据\n\t\t\t若watch监视的是reactive定义的响应式数据，则无法正确获得oldValue！！\n\t\t\t若watch监视的是reactive定义的响应式数据，则强制开启了深度监视 \n*/\nwatch(\n  person,\n  (newValue, oldValue) => &#123;\n    console.log(\"person变化了\", newValue, oldValue);\n  &#125;,\n  &#123; immediate: true, deep: false &#125;\n); //此处的deep配置不再奏效\n\n//情况四：监视reactive定义的响应式数据中的某个属性\nwatch(\n  () => person.job,\n  (newValue, oldValue) => &#123;\n    console.log(\"person的job变化了\", newValue, oldValue);\n  &#125;,\n  &#123; immediate: true, deep: true &#125;\n);\n\n//情况五：监视reactive定义的响应式数据中的某些属性\nwatch(\n  [() => person.job, () => person.name],\n  (newValue, oldValue) => &#123;\n    console.log(\"person的job变化了\", newValue, oldValue);\n  &#125;,\n  &#123; immediate: true, deep: true &#125;\n);\n\n//特殊情况\nwatch(\n  () => person.job,\n  (newValue, oldValue) => &#123;\n    console.log(\"person的job变化了\", newValue, oldValue);\n  &#125;,\n  &#123; deep: true &#125;\n); //此处由于监视的是reactive素定义的对象中的某个属性，所以deep配置有效\n\n3.watchEffect 函数\nwatch 的套路是：既要指明监视的属性，也要指明监视的回调。\n\nwatchEffect 的套路是：不用指明监视哪个属性，监视的回调中用到哪个属性，那就监视哪个属性。\n\nwatchEffect 有点像 computed：\n\n但 computed 注重的计算出来的值（回调函数的返回值），所以必须要写返回值。\n而 watchEffect 更注重的是过程（回调函数的函数体），所以不用写返回值。\n\n//watchEffect所指定的回调中用到的数据只要发生变化，则直接重新执行回调。\nwatchEffect(() => &#123;\n  const x1 = sum.value;\n  const x2 = person.age;\n  console.log(\"watchEffect配置的回调执行了\");\n&#125;);\n\n8.生命周期\nVue3.0 中可以继续使用 Vue2.x 中的生命周期钩子，但有有两个被更名：\nbeforeDestroy改名为 beforeUnmount\ndestroyed改名为 unmounted\n\n\nVue3.0 也提供了 Composition API 形式的生命周期钩子，与 Vue2.x 中钩子对应关系如下：\nbeforeCreate===&gt;setup()\ncreated=======&gt;setup()\nbeforeMount ===&gt;onBeforeMount\nmounted=======&gt;onMounted\nbeforeUpdate===&gt;onBeforeUpdate\nupdated =======&gt;onUpdated\nbeforeUnmount ==&gt;onBeforeUnmount\nunmounted =====&gt;onUnmounted\n\n\n\n9.自定义 hook 函数\n什么是 hook？—— 本质是一个函数，把 setup 函数中使用的 Composition API 进行了封装。\n\n类似于 vue2.x 中的 mixin。\n\n自定义 hook 的优势: 复用代码, 让 setup 中的逻辑更清楚易懂。\n\n\n10.toRef\n作用：创建一个 ref 对象，其 value 值指向另一个对象中的某个属性。\n\n语法：const name = toRef(person,&#39;name&#39;)\n\n应用: 要将响应式对象中的某个属性单独提供给外部使用时。\n\n扩展：toRefs 与toRef功能一致，但可以批量创建多个 ref 对象，语法：toRefs(person)\n\n\n三、其它 Composition API1.shallowReactive 与 shallowRef\nshallowReactive：只处理对象最外层属性的响应式（浅响应式）。\n\nshallowRef：只处理基本数据类型的响应式, 不进行对象的响应式处理。\n\n什么时候使用?\n\n如果有一个对象数据，结构比较深, 但变化时只是外层属性变化 ===&gt; shallowReactive。\n如果有一个对象数据，后续功能不会修改该对象中的属性，而是生新的对象来替换 ===&gt; shallowRef。\n\n\n\n2.readonly 与 shallowReadonly\nreadonly: 让一个响应式数据变为只读的（深只读）。\nshallowReadonly：让一个响应式数据变为只读的（浅只读）。\n应用场景: 不希望数据被修改时。\n\n3.toRaw 与 markRaw\ntoRaw：\n作用：将一个由reactive生成的响应式对象转为普通对象。\n使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作，不会引起页面更新。\n\n\nmarkRaw：\n作用：标记一个对象，使其永远不会再成为响应式对象。\n应用场景:\n有些值不应被设置为响应式的，例如复杂的第三方类库等。\n当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能。\n\n\n\n\n\n4.customRef\n作用：创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制。\n\n实现防抖效果：\n&lt;template&gt;\n  &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;keyword&quot; &#x2F;&gt;\n  &lt;h3&gt;&#123;&#123; keyword &#125;&#125;&lt;&#x2F;h3&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport &#123; ref, customRef &#125; from &quot;vue&quot;;\nexport default &#123;\n  name: &quot;Demo&quot;,\n  setup() &#123;\n    &#x2F;&#x2F; let keyword &#x3D; ref(&#39;hello&#39;) &#x2F;&#x2F;使用Vue准备好的内置ref\n    &#x2F;&#x2F;自定义一个myRef\n    function myRef(value, delay) &#123;\n      let timer;\n      &#x2F;&#x2F;通过customRef去实现自定义\n      return customRef((track, trigger) &#x3D;&gt; &#123;\n        return &#123;\n          get() &#123;\n            track(); &#x2F;&#x2F;告诉Vue这个value值是需要被“追踪”的\n            return value;\n          &#125;,\n          set(newValue) &#123;\n            clearTimeout(timer);\n            timer &#x3D; setTimeout(() &#x3D;&gt; &#123;\n              value &#x3D; newValue;\n              trigger(); &#x2F;&#x2F;告诉Vue去更新界面\n            &#125;, delay);\n          &#125;,\n        &#125;;\n      &#125;);\n    &#125;\n    let keyword &#x3D; myRef(&quot;hello&quot;, 500); &#x2F;&#x2F;使用程序员自定义的ref\n    return &#123;\n      keyword,\n    &#125;;\n  &#125;,\n&#125;;\n&lt;&#x2F;script&gt;\n\n5.provide 与 inject -->\n\n\n作用：实现祖与后代组件间通信\n\n套路：父组件有一个 provide 选项来提供数据，后代组件有一个 inject 选项来开始使用这些数据\n\n具体写法：\n\n祖组件中：\nsetup()&#123;\n\t......\n    let car = reactive(&#123;name:'奔驰',price:'40万'&#125;)\n    provide('car',car)\n    ......\n&#125;\n后代组件中：\nsetup(props,context)&#123;\n\t......\n    const car = inject('car')\n    return &#123;car&#125;\n\t......\n&#125;\n\n\n\n6.响应式数据的判断\nisRef: 检查一个值是否为一个 ref 对象\nisReactive: 检查一个对象是否是由 reactive 创建的响应式代理\nisReadonly: 检查一个对象是否是由 readonly 创建的只读代理\nisProxy: 检查一个对象是否是由 reactive 或者 readonly 方法创建的代理\n\n四、Composition API 的优势1.Options API 存在的问题使用传统 OptionsAPI 中，新增或者修改一个需求，就需要分别在 data，methods，computed 里修改 。\n\n    \n\n\n     \n\n\n2.Composition API 的优势我们可以更加优雅的组织我们的代码，函数。让相关功能的代码更加有序的组织在一起。\n\n    \n\n\n    \n\n\n五、新的组件1.Fragment\n在 Vue2 中: 组件必须有一个根标签\n在 Vue3 中: 组件可以没有根标签, 内部会将多个标签包含在一个 Fragment 虚拟元素中\n好处: 减少标签层级, 减小内存占用\n\n2.Teleport\n什么是 Teleport？—— Teleport 是一种能够将我们的组件 html 结构移动到指定位置的技术。\n&lt;teleport to&#x3D;&quot;移动位置&quot;&gt;\n\t&lt;div v-if&#x3D;&quot;isShow&quot; class&#x3D;&quot;mask&quot;&gt;\n\t\t&lt;div class&#x3D;&quot;dialog&quot;&gt;\n\t\t\t&lt;h3&gt;我是一个弹窗&lt;&#x2F;h3&gt;\n\t\t\t&lt;button @click&#x3D;&quot;isShow &#x3D; false&quot;&gt;关闭弹窗&lt;&#x2F;button&gt;\n\t\t&lt;&#x2F;div&gt;\n\t&lt;&#x2F;div&gt;\n&lt;&#x2F;teleport&gt;\n\n3.Suspense\n等待异步组件时渲染一些额外内容，让应用有更好的用户体验\n\n使用步骤：\n\n异步引入组件\nimport &#123; defineAsyncComponent &#125; from \"vue\";\nconst Child = defineAsyncComponent(() => import(\"./components/Child.vue\"));\n使用Suspense包裹组件，并配置好default 与 fallback\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;app&quot;&gt;\n    &lt;h3&gt;我是App组件&lt;&#x2F;h3&gt;\n    &lt;Suspense&gt;\n      &lt;template v-slot:default&gt;\n        &lt;Child &#x2F;&gt;\n      &lt;&#x2F;template&gt;\n      &lt;template v-slot:fallback&gt;\n        &lt;h3&gt;加载中.....&lt;&#x2F;h3&gt;\n      &lt;&#x2F;template&gt;\n    &lt;&#x2F;Suspense&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n\n\n六、其他1.全局 API 的转移\nVue 2.x 有许多全局 API 和配置。\n\n例如：注册全局组件、注册全局指令等。\n//注册全局组件\nVue.component('MyButton', &#123;\n  data: () => (&#123;\n    count: 0\n  &#125;),\n  template: '&lt;button @click=\"count++\">Clicked &#123;&#123; count &#125;&#125; times.&lt;/button>'\n&#125;)\n\n//注册全局指令\nVue.directive('focus', &#123;\n  inserted: el => el.focus()\n&#125;\n\n\nVue3.0 中对这些 API 做出了调整：\n\n将全局的 API，即：Vue.xxx调整到应用实例（app）上\n\n\n\n2.x 全局 API（Vue）\n3.x 实例 API (app)\n\n\n\nVue.config.xxxx\napp.config.xxxx\n\n\nVue.config.productionTip\n移除\n\n\nVue.component\napp.component\n\n\nVue.directive\napp.directive\n\n\nVue.mixin\napp.mixin\n\n\nVue.use\napp.use\n\n\nVue.prototype\napp.config.globalProperties\n\n\n\n\n\n\n2.其他改变\ndata 选项应始终被声明为一个函数。\n\n过度类名的更改：\n\nVue2.x 写法\n.v-enter,\n.v-leave-to &#123;\n  opacity: 0;\n&#125;\n.v-leave,\n.v-enter-to &#123;\n  opacity: 1;\n&#125;\nVue3.x 写法\n.v-enter-from,\n.v-leave-to &#123;\n  opacity: 0;\n&#125;\n\n.v-leave-from,\n.v-enter-to &#123;\n  opacity: 1;\n&#125;\n\n\n移除keyCode 作为 v-on 的修饰符，同时也不再支持config.keyCodes\n\n移除v-on.native修饰符\n\n父组件中绑定事件\n&lt;my-component\n  v-on:close&#x3D;&quot;handleComponentEvent&quot;\n  v-on:click&#x3D;&quot;handleNativeClickEvent&quot;\n&#x2F;&gt;\n子组件中声明自定义事件\n&lt;script&gt;\nexport default &#123;\n  emits: [&quot;close&quot;],\n&#125;;\n&lt;&#x2F;script&gt;\n\n\n移除过滤器（filter）\n\n\n\n\n\n\n\n\n\n过滤器虽然这看起来很方便，但它需要一个自定义语法，打破大括号内表达式是 “只是 JavaScript” 的假设，这不仅有学习成本，而且有实现成本！建议用方法调用或计算属性去替换过滤器。\n\n\n\n","slug":"vue3快速上手","date":"2022-12-26T13:14:11.604Z","categories_index":"Vue","tags_index":"vue3","author_index":"LCS's Blog"},{"id":"dbb6c028fbfaa3a60ce8fdef149ba11b","title":"ES6新增","content":"ES6 有哪些新增块作用域 (let 变量 const 常量)\n类 （class)\n箭头函数 ( ()=&gt;{} )\n模板字符串(反引号 ``)\n对象解构\nPromise\n模块化 ( import 导入 export 导出)\nSymbol （独一无二的值）ES6 新引入的一种原始数据类型，表示独一无二的值。它是 js 第七种数据类型 是一种类似于字符串的数据类型。\n代理（proxy）\nSet （新的数据结构，里面的值都是唯一不重复的）（类数组，我们一般称为集合）\n字典（Map）【 Map 类型是键值对的有序列表，而键和值都可以是任意类型 】\n函数默认参数 （ function (name=’张三’){} ）\nrest 用来代替 arguments，直接获取一个真数组，方便操作 (arguments 返回的是伪数组)（可以…rest 扩展）\n扩展运算符（…能将「数组」转为逗号分隔的「参数序列] ,是 rest 的逆运算)\n数组和对象的扩展\n","slug":"ES6有哪些新增","date":"2022-12-26T13:14:11.603Z","categories_index":"web前端","tags_index":"ES6笔记","author_index":"LCS's Blog"}]